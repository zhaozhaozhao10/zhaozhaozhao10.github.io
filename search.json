[{"title":"node.js","url":"/2023/10/31/02-node.js%E4%BB%8B%E7%BB%8D/","content":"node.js 介绍node.js 是什么？\nnode.js 是一个开发平台，就像Java开发平台、.Net开发平台、PHP开发平台、Apple开发平台一样。\n\n\n何为开发平台？有对应的编程语言、有语言运行时、有能实现特定功能的API（SDK：Software Development Kit）\n\n\nnodejs平台使用的编程语言是 JavaScript 语言。 \n不支持 window、document、bom 对象。\n\n\nnode.js 平台是基于 Chrome V8 JavaScript 引擎构建。\n基于 node.js 可以开发控制台程序（命令行程序、CLI程序）、桌面应用程序（GUI）、（借助 node-webkit、electron 等框架实现）、Web 应用程序（网站）。\n\nPHP开发技术栈: LAMP - Linux Apache MySQL PHP\nnode.js 全栈开发技术栈: MEAN - MongoDB Express Angular Node.js\nnode.js 有哪些特点？\n事件驱动(当事件被触发时，执行传递过去的回调函数)\n非阻塞 I&#x2F;O 模型（当执行I&#x2F;O操作时，不会阻塞线程）\n单线程\n拥有世界最大的开源库生态系统 —— npm。\n\nnode.js 网站\nnode.js官方网站\nnode.js中文网\nnode.js 中文社区\n\n为什么要学习Node.js?\n通过学习Node.js开发深入理解服务器开发、Web请求和响应过程、 了解服务器端如何与客户端配合\n学习服务器端渲染：art-template、ejs、jsp\n学习服务器端为客户端编写接口\n现在前端工程师面试，对 Node.js 开发有要求\n补充提问：\n\n\n在Node.js平台开发时，能使用Dom API吗？比如：document.getElementById(&#39;id&#39;); window.location 等?\n\n\n复习 浏览器端 JavaScript 组成：ECMAscript、Dom、Bom\n\n学习目标\n了解服务器开发过程\n\n会使用 node.js 开发基本的 http 服务程序（Web应用程序）\n\n\nNode.js可以用来做什么？\n具有复杂逻辑的动态网站 \nWebSocket服务器 \n命令行工具 \n带有图形界面的本地应用程序 \n……\n\n终端基本使用打开应用\nnotepad 打开记事本\nmspaint 打开画图\ncalc 打开计算机\nwrite 写字板\nsysdm.cpl 打开环境变量设置窗口\n\n常用命令\nmd 创建目录\nrmdir(rd) 删除目录，目录内没有文档\necho on a.txt 创建空文件\ndel 删除文件\nrm 文件名 删除文件\n\nNode.js开发环境准备\n普通安装方式官方网站\n\n多版本安装方式  centOS  ubuntu\n\n卸载已有的Node.js\n下载nvm\n在C盘创建目录dev\n在dev目中中创建两个子目录nvm和nodejs\n并且把nvm包解压进去nvm目录中\n在install.cmd文件上面右键选择【以管理员身份运行】\n打开的cmd窗口直接回车会生成一个settings.txt文件，修改文件中配置信息\n配置nvm和Node.js环境变量\nNVM_HOME:C:\\dev\\nvm\nNVM_SYMLINK:C:\\dev\\nodejs\n\n\n把配置好的两个环境变量加到Path中\n\n\n\nnvm常用的命令\nnvm list 查看当前安装的Node.js所有版本\nnvm install 版本号 安装指定版本的Node.js\nnvm uninstall 版本号 卸载指定版本的Node.js\nnvm use 版本号 选择指定版本的Node.js\n\nNode.js之HelloWorld\n命令行方式REPL\n运行文件方式\n全局对象概览\n\nNode.js 开发 Web 应用程序 和 PHP、Java、ASP.Net等传统模式开发Web应用程序区别\n传统模式\n\n\n有 Web 容器\n\n\nNode.js开发Web应用程序\n\n\n没有 Web 容器\n\n \n\n补充提问：\n\n\n什么是动态网页？什么是静态网页？\n\n在 node.js 上编写程序REPL介绍\nREPL 全称: Read-Eval-Print-Loop（交互式解释器）\n\n\nR 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。\nE 执行 - 执行输入的数据结构\nP 打印 - 输出结果\nL 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。\n\n\n在REPL中编写程序 （类似于浏览器开发人员工具中的控制台功能）\n\n\n直接在控制台输入 node 命令进入 REPL 环境\n\n\n按两次 Control + C 退出REPL界面 或者 输入 .exit 退出 REPL 界面\n\n\n按住 control 键不要放开, 然后按两下 c 键\n\n创建 JavaScript 文件编写程序JavaScript 文件名命名规则\n不要用中文\n不要包含空格\n不要出现node关键字，比如：node.js\n建议以 ‘-‘ 分割单词\n\n案例\n案例1：编写一个简单的函数, 实现数字相加\n\nvar n = 10;var m = 100;function add(x, y) &#123;  return x + y;&#125;var result = add(m, n);console.log(&#x27;计算结果是：&#x27; + result);\n\n\n\n\n案例：文件读写案例\n\n\n使用到的模块var fs = require(&#39;fs&#39;);\n\n1、写文件：fs.writeFile(file, data[, options], callback);\n\n参数1：要写入的文件路径，必填。\n参数2：要写入的数据，必填。\n参数3：写入文件时的选项，比如：文件编码，选填。\n参数4：文件写入完毕后的回调函数，必填。\n写文件注意：\n该操作采用异步执行\n如果文件已经存在则替换掉\n默认写入的文件编码为utf8\n回调函数有1个参数：err，表示在写入文件的操作过程中是否出错了。\n如果出错了err != null，否则 err === null\n\n\n\n\n\n\n2、读文件：fs.readFile(file[, options], callback)\n\n参数1：要读取的文件路径，必填。\n参数2：读取文件时的选项，比如：文件编码。选填。\n参数3：文件读取完毕后的回调函数，必填。\n读文件注意：\n该操作采用异步执行\n回调函数有两个参数，分别是err和data\n如果读取文件时没有指定编码，那么返回的将是原生的二进制数据；如果指定了编码，那么会根据指定的编码返回对应的字符串数据。\n\n\n\n\n注意：\n\n文件操作中的./表示当前路径，相对的是执行node命令的路径，而不是当前被执行的*.js文件的实际路径。\n__dirname才永远表示当前被执行的*.js文件的实际路径\n/表示根目录, 读取文件或写入文件的时候写/目录，在Windows下相当于当前磁盘根目录（比如：c:\\ 或 d:\\ 或 e:\\  等，在Mac下相当于硬盘根目录 /）\n\n\n\n// --------------------------------- 写文件 -----------------------------// 加载文件操作模块var fs = require(&#x27;fs&#x27;);// 创建要写入的文件的字符串var msg = &#x27;你好，世界！你好 Node.js.&#x27;;// 执行文件写入操作fs.writeFile(&#x27;./data.txt&#x27;, msg, &#x27;utf8&#x27;, function (err) &#123;  console.log(&#x27;---&#x27; + err + &#x27;----&#x27;);  // /判断是否写入文件出错了  if (err) &#123;    console.log(&#x27;文件写入出错了，详细错误信息：&#x27; + err);    // 把错误继续向上抛出    throw err;  &#125; else &#123;    console.log(&#x27;文件写入成功！&#x27;);  &#125;&#125;);// --------------------------------- 读文件 -----------------------------// 加载文件操作模块var fs = require(&#x27;fs&#x27;);// 执行文件读取操作fs.readFile(&#x27;./data.txt&#x27;, &#x27;utf8&#x27;, function (err, data) &#123;  // 输出err  和 data  // console.log(&#x27;error: &#x27; + err);  // console.log(&#x27;data: &#x27; + data);  if (err) &#123;    console.log(&#x27;文件读取出错啦！详细信息: &#x27; + err);  &#125; else &#123;    console.log(&#x27;文件读取成功，以下是文件内容：&#x27;);    console.log(data);  &#125;&#125;);\n\n\n\n\n案例4：创建目录案例\n\n// 创建一个文件夹// 加载文件操作模块var fs = require(&#x27;fs&#x27;);// 创建一个目录fs.mkdir(&#x27;./test-mkdir&#x27;, function (err) &#123;  if (err) &#123;    console.log(&#x27;创建目录出错了，详细信息如下：&#x27;);    console.log(err);  &#125; else &#123;    console.log(&#x27;目录创建成功！&#x27;);  &#125;&#125;);// ----------------------------------------------------------// 加载文件操作模块var fs = require(&#x27;fs&#x27;);// 1. 创建 &#x27;01-教学资料&#x27; 目录fs.mkdir(&#x27;./01-教学资料&#x27;, function (err) &#123;  if (err) &#123;    throw err;  &#125;  // 1.1 创建 &#x27;01-笔记大纲&#x27; 目录  fs.mkdir(&#x27;./01-教学资料/01-笔记大纲&#x27;);  // 1.2 创建 &#x27;02-作业任务&#x27; 目录  fs.mkdir(&#x27;./01-教学资料/02-作业任务&#x27;);  // 1.3 创建 &#x27;03-素材资料&#x27; 目录  fs.mkdir(&#x27;./01-教学资料/03-素材资料&#x27;);  // 1.4 创建 &#x27;04-随堂笔记&#x27; 目录  fs.mkdir(&#x27;./01-教学资料/04-随堂笔记&#x27;);&#125;);// 2. 创建 &#x27;02-源代码&#x27; 目录fs.mkdir(&#x27;./02-源代码&#x27;, function (err) &#123;  if (err) &#123;    throw err;  &#125;  // 2.1 创建 &#x27;预习代码&#x27;目录  fs.mkdir(&#x27;./02-源代码/预习代码&#x27;);  // 2.2 创建 &#x27;课堂代码&#x27;目录  fs.mkdir(&#x27;./02-源代码/课堂代码&#x27;);&#125;);// 3. 创建 &#x27;03-视频&#x27; 目录fs.mkdir(&#x27;./03-视频&#x27;);// 4. 创建 &#x27;04-其他资料&#x27; 目录fs.mkdir(&#x27;./04-其他资料&#x27;);\n\n\n\n注意：\n异步操作无法通过 try-catch 来捕获异常，要通过判断 error 来判断是否出错。\n同步操作可以通过 try-catch 来捕获异常。\n不要使用 fs.exists(path, callback) 来判断文件是否存在，直接判断 error 即可\n文件操作时的路径问题\n\n\n在读写文件的时候 ‘.&#x2F;‘ 表示的是当前执行node命令的那个路径，不是被执行的js文件的路径\n__dirname, 表示的永远是”当前被执行的js的目录”\n__filename, 表示的是”被执行的js的文件名（含路径)”\n\n\nerror-first 介绍( 错误优先 )\n\n案例5：通过 node.js 编写 http 服务程序 - 极简版本步骤：\n\n加载http模块\n创建http服务\n为http服务对象添加 request 事件处理程序\n开启http服务监听，准备接收客户端请求\n\n注意：\n\n浏览器显示可能是乱码，所以可以通过 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain; charset=utf-8&#39;);设置浏览器显示时所使用的编码。\n\nChrome 浏览器默认无法手动设置编码，需要安装”Set Character Encoding”扩展。\n\n演示一下设置Content-Type=text/html 和 Content-Type=text/plain的区别。\n\n\n参考代码：\n// 1. 加载http模块var http = require(&#x27;http&#x27;);// 2. 创建http服务var server = http.createServer();// 3. 开始监听&#x27;request&#x27;事件server.on(&#x27;request&#x27;, function (req, res) &#123;  // body...  console.log(&#x27;有人请求了~~&#x27;);&#125;);// 4. 启动服务，开始监听server.listen(9000, function () &#123;  console.log(&#x27;服务已经启动，请访问： http://localhost:9000&#x27;);&#125;);\n\n\n\n\n案例6：通过 node.js 编写 http 服务程序 - 根据不同请求作出不同响应说明：\n根据不同请求，显示index页面、login页面、register页面、list页面。\n请求 &#x2F; 或 &#x2F;index\n请求 &#x2F;login\n请求 &#x2F;register\n请求 &#x2F;list\n\n参考代码// 加载http模块var http = require(&#x27;http&#x27;);// 创建http servervar server = http.createServer(function (req, res) &#123;  // body...  console.log(req.url);  if (req.url === &#x27;/&#x27; || req.url === &#x27;/index&#x27;) &#123;    // 表示请求网站首页    res.end(&#x27;这是 index.html&#x27;);  &#125; else if (req.url === &#x27;/login&#x27;) &#123;    // 表示请求登录页面    res.end(&#x27;这是 login.html&#x27;);  &#125; else if (req.url === &#x27;/register&#x27;) &#123;    // 表示请求注册页面    res.end(&#x27;这是 register.html&#x27;);      &#125; else if (req.url === &#x27;/list&#x27;) &#123;    // 表示请求列表页面    res.end(&#x27;这是 list.html&#x27;);      &#125; else &#123;    // 表示请求的页面不存在    res.writeHead(404, &#x27;Not Found&#x27;);    res.end(&#x27;Sorry, page not found.&#x27;);  &#125;&#125;);// 监听端口的网络请求server.listen(9000, function () &#123;  console.log(&#x27;http://localhost:9000&#x27;);&#125;);\n\n\n\n\n案例7：通过 node.js 编写 http 服务程序 - 通过读取静态 HTML 文件来响应用户请求步骤：\n\n创建index.html、login.html、register.html、list.html、404.html文件。 \n演示通过读取最简单的 HTML 文件来响应用户。\n演示通过读取”具有引入外部CSS样式表”的HTML文件来响应用户。\n演示通过读取”具有img标签”的HTML文件来响应用户。\n\n注意：\n\n1、注意在发送不同类型的文件时，要设置好对应的Content-Type\n\nContent-Type参考 OSChina\nContent-Type参考 MDN\n\n\n2、HTTP状态码参考\n\nw3org参考\nw3schools参考\n\n\n3、在html页面中写相对路径’.&#x2F;‘ 和 绝对路径 ‘&#x2F;‘的含义 。\n\n网页中的这个路径主要是告诉浏览器向哪个地址发起请求用的\n‘.&#x2F;‘ 表示本次请求从相对于当前页面的请求路径（即服务器返回当前页面时的请求路径）开始\n‘&#x2F;‘ 表示请求从根目录开始\n\n\n\n补充知识点：\n\npath 模块的 join() 方法\n\n参考代码：\n// 1. 加载 http 模块var http = require(&#x27;http&#x27;);// 加载文件操作模块var fs = require(&#x27;fs&#x27;);// 加载path模块，这个模块主要用来处理各种路径。var path = require(&#x27;path&#x27;);// 2. 创建http servervar server = http.createServer(function (req, res) &#123;  // 1. 获取用户请求的URL  var url = req.url.toLowerCase();  // 2. 根据用户的不同请求，做出不同响应  if (url === &#x27;/&#x27; || url === &#x27;/index&#x27;) &#123;    // 读取index.html文件，把该文件响应给用户    fs.readFile(path.join(__dirname, &#x27;index.html&#x27;), function (err, data) &#123;      if (err) &#123;        throw err;      &#125;      res.writeHead(200, &#x27;OK&#x27;, &#123;        &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;      &#125;);      // res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);      res.end(data);    &#125;);  &#125; else if (url === &#x27;/login&#x27;) &#123;    // 读取login.html文件，把该文件响应给用户    fs.readFile(path.join(__dirname, &#x27;login.html&#x27;), function (err, data) &#123;      if (err) &#123;        throw err;      &#125;      res.writeHead(200, &#x27;OK&#x27;, &#123;        &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;      &#125;);      // res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);      res.end(data);    &#125;);  &#125; else if (url === &#x27;/register&#x27;) &#123;    // 读取register.html文件，把该文件响应给用户    fs.readFile(path.join(__dirname, &#x27;register.html&#x27;), function (err, data) &#123;      if (err) &#123;        throw err;      &#125;      res.writeHead(200, &#x27;OK&#x27;, &#123;        &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;      &#125;);      // res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);      res.end(data);    &#125;);  &#125; else if (url === &#x27;/404&#x27;) &#123;    // 读取register.html文件，把该文件响应给用户    fs.readFile(path.join(__dirname, &#x27;404.html&#x27;), function (err, data) &#123;      if (err) &#123;        throw err;      &#125;      res.writeHead(200, &#x27;OK&#x27;, &#123;        &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;      &#125;);      // res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);      res.end(data);    &#125;);  &#125;  &#125;);// 3. 启动服务server.listen(9090, function () &#123;  // body...  console.log(&#x27;please visit: http://localhost:9090&#x27;);&#125;);\n\n\n\n案例8：模拟 Apache 实现静态资源服务器步骤：\n\n单独创建一个目录来实现，比如：创建一个”07-Apache”的目录。\n在该目录下新建 public 目录，假设该目录为静态资源目录。\n根据用户请求的路径在 public 目录下寻找对应路径下的资源。\n如果找到了，那么将该资源返回给用户，如果没找到则返回404错误。\n通过 mime 模块设置不同类型资源的Content-Type\n实现完毕后把素材中的’An Ocean of Sky’ 和 ‘Hacker News’分别拷贝到静态资源目录下, 测试是否成功\n\n其他：\n\n介绍 NPM\n介绍 mime 第三方模块\nnpm install mime\n在代码中直接 var mime = require(&#39;mime&#39;)\n\n\n\n参考代码：\n// 1. 加载对应模块// 1.1 加载http模块var http = require(&#x27;http&#x27;);// 1.2 加载path模块，方便路径拼接var path = require(&#x27;path&#x27;);// 1.3 加载文件读取模块var fs = require(&#x27;fs&#x27;);// 1.4 加载判断文件MIME类型的模块var mime = require(&#x27;mime&#x27;);// 2. 创建http servervar server = http.createServer();// 3. 监听用户request事件server.on(&#x27;request&#x27;, function (req, res) &#123;  // 1. 获取用户的请求路径, 并转换为小写  var url = req.url.toLowerCase();  // 判断如果请求的路径是 &#x27;/&#x27; 那么等价于 &#x27;/index.html&#x27;  url = (url === &#x27;/&#x27;) ? &#x27;/index.html&#x27; : url;  // 2. 根据用户请求的url路径, 去public目录下查找对应的静态资源文件。找到后读取该文件，并将结果返回给用户  // 2.1 根据用户请求的url拼接本地资源文件的路径   var filePath = path.join(__dirname, &#x27;public&#x27;, url);  // 2.2 根据请求的文件路径设置Content-Type  res.setHeader(&#x27;Content-Type&#x27;, mime.lookup(url));  // 2.2 根据路径去读取对应的文件  // 【注意】读取文件前无需判断文件是否已经存在，而是在读取文件的回调函数中根据error的错误信息来判断读取文件是否成功以及发生的错误  fs.readFile(filePath, function (err, data) &#123;    // 判断是否有错误    if (err) &#123;      if (err.code === &#x27;ENOENT&#x27;) &#123; // 判断是否是请求的文件是否不存在        res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf8&#x27;);        res.statusCode = 404;        res.statusMessage = &#x27;Not Found&#x27;;        res.end(&#x27;&lt;h1&gt;请求的资源不存在！&lt;/h1&gt;&#x27;);      &#125; else if (err.code === &#x27;EACCES&#x27;) &#123; // 判断文件是否有访问权限        res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf8&#x27;);        res.statusCode = 403;        res.statusMessage = &#x27;Forbidden&#x27;;        res.end(&#x27;&lt;h1&gt;Permission denied！&lt;/h1&gt;&#x27;);      &#125; else &#123;        throw err;        &#125;    &#125; else &#123;            // 如果没有错误则将读取到的文件返回给用户      res.statusCode = 200;      res.statusMessage = &#x27;OK&#x27;;      res.end(data);    &#125;  &#125;)&#125;);// 4. 启动服务server.listen(9000, function () &#123;  // body...  console.log(&#x27;server is running, please visit: http://localhost:9000&#x27;);&#125;);\n\n\n\nCommon System Errors - 常见错误号\nEACCES (Permission denied)\n\nAn attempt was made to access a file in a way forbidden by its file access permissions.\n访问被拒绝\n\n\nEADDRINUSE (Address already in use)\n\nAn attempt to bind a server (net, http, or https) to a local address failed due to another server on the local system already occupying that address.\n地址正在被使用（比如：端口号备占用）\n\n\nEEXIST (File exists)\n\nAn existing file was the target of an operation that required that the target not exist.\n文件已经存在\n\n\nEISDIR (Is a directory)\n\nAn operation expected a file, but the given pathname was a directory.\n给定的路径是目录\n\n\nENOENT (No such file or directory)\n\nCommonly raised by fs operations to indicate that a component of the specified pathname does not exist – no entity (file or directory) could be found by the given path.\n文件 或 目录不存在\n\n\nENOTDIR (Not a directory)\n\nA component of the given pathname existed, but was not a directory as expected. Commonly raised by fs.readdir.\n给定的路径不是目录\n\n\n\n同步文件操作 和 异步文件操作\nfs.readFile(file[, options], callback)\nfs.readFileSync(file[, options])\n\n通过设置 http 响应报文头实现弹框下载功能\n设置 Content-Type: application/octet-stream\n设置 Content-Disposition: attachment; filename=demo.txt\n\n"},{"title":"跳动爱心","url":"/2023/10/31/03-%E7%88%B1%E5%BF%83%E4%BB%A3%E7%A0%81/","content":"&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;跳动爱心&lt;/title&gt;    &lt;style&gt;      * &#123;        padding: 0;        margin: 0;      &#125;      body &#123;        background-color: pink;      &#125;      #frame &#123;        position: relative;        width: 400px;        height: 300px;        margin: 250px auto;      &#125;      .left,      .right &#123;        top: 0;        width: 200px;        height: 200px;        border-radius: 50%;      &#125;      .left &#123;        left: 35px;      &#125;      .right &#123;        right: 35px;        z-index: -1;      &#125;      .bottom &#123;        bottom: 36px;        left: 100px;        width: 200px;        height: 200px;        transform: rotate(45deg);        z-index: -1;      &#125;      .heart &#123;        position: absolute;        box-shadow: 0 0 40px #d5093c;        animation: beat 0.8s ease infinite normal;        background: linear-gradient(-90deg, #f50a45 0%, #d5093c 40%);      &#125;      @keyframes beat &#123;        0% &#123;          transform: scale(1) rotate(225deg);          box-shadow: 0 0 40px #d5093c;        &#125;        50% &#123;          transform: scale(1.1) rotate(225deg);          box-shadow: 0 0 70px #d5093c;        &#125;        100% &#123;          transform: scale(1) rotate(225deg);          box-shadow: 0 0 40px #d5093c;        &#125;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;frame&quot;&gt;      &lt;div class=&quot;heart left&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;heart right&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;heart bottom&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;"},{"title":"简易版带验证码的登录和注册js+jq","url":"/2023/11/01/04-%E7%AE%80%E6%98%93%E7%89%88%E5%B8%A6%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E7%99%BB%E5%BD%95%E5%92%8C%E6%B3%A8%E5%86%8C/","content":"&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.js&quot;&gt;&lt;/script&gt;  &lt;style&gt;    *&#123;      margin: 0;      padding: 0;    &#125;    #lu&#123;      display: none;    &#125;    #yanzheng&#123;      width: 100vw;      height: 100vh;      background-color: rgba(0, 0, 0, 0.7);      position: absolute;      top: 0;      left: 0;      display: none;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div&gt;    &lt;div&gt;      &lt;span onclick=&quot;zhuc()&quot;&gt;注册&lt;/span&gt;      &lt;span onclick=&quot;dengl()&quot;&gt;登录&lt;/span&gt;    &lt;/div&gt;    &lt;div id=&quot;ce&quot;&gt;      &lt;input type=&quot;text&quot; name=&quot;user&quot; id=&quot;ceuser&quot;&gt;      &lt;br&gt;      &lt;input type=&quot;text&quot; name=&quot;pwd&quot; id=&quot;cepwd&quot;&gt;      &lt;br&gt;      &lt;button id=&quot;zce&quot;&gt;注册&lt;/button&gt;    &lt;/div&gt;    &lt;div id=&quot;yanzheng&quot;&gt;      &lt;input type=&quot;text&quot; name=&quot;yan&quot; id=&quot;yan&quot;&gt;      &lt;br&gt;      &lt;button id=&quot;que&quot;&gt;确认&lt;/button&gt;    &lt;/div&gt;    &lt;div id=&quot;lu&quot;&gt;      &lt;input type=&quot;text&quot; name=&quot;duser&quot; id=&quot;luuser&quot;&gt;      &lt;br&gt;      &lt;input type=&quot;text&quot; name=&quot;dpwd&quot; id=&quot;lupwd&quot;&gt;      &lt;br&gt;      &lt;button id=&quot;dengl&quot;&gt;登录&lt;/button&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    function zhuc() &#123;      $(&#x27;#ce&#x27;).show()      $(&#x27;#lu&#x27;).hide()    &#125;    function dengl() &#123;      $(&#x27;#ce&#x27;).hide()      $(&#x27;#lu&#x27;).show()    &#125;    var aa = Math.floor(Math.random()* (9999-1000)+1000)    $(&#x27;#zce&#x27;).click(()=&gt;&#123;      $(&#x27;#yanzheng&#x27;).show()      console.log(aa);    &#125;)    $(&#x27;#que&#x27;).click(()=&gt;&#123;      if(aa == Number($(&#x27;#yan&#x27;).val()))&#123;        sessionStorage.setItem(&#x27;zhuce&#x27;,JSON.stringify(&#123;ceuser:$(&#x27;#ceuser&#x27;).val(),cepwd:$(&#x27;#cepwd&#x27;).val()&#125;))        $(&#x27;#yanzheng&#x27;).hide()        $(&#x27;#ce&#x27;).hide()        $(&#x27;#lu&#x27;).show()      &#125;else&#123;        alert(&#x27;输入的验证码不对&#x27;)      &#125;    &#125;)    $(&#x27;#dengl&#x27;).click(()=&gt;&#123;      let aa = JSON.parse(sessionStorage.getItem(&#x27;zhuce&#x27;))      console.log(aa);      if(aa.ceuser == Number($(&#x27;#luuser&#x27;).val())&amp;&amp;aa.cepwd == Number($(&#x27;#lupwd&#x27;).val()))&#123;        alert(&#x27;登录成功&#x27;)      &#125;else&#123;        if(aa.ceuser == Number($(&#x27;#luuser&#x27;).val()))&#123;          alert(&#x27;密码错误&#x27;)        &#125;else&#123;          alert(&#x27;账号不存在&#x27;)        &#125;      &#125;    &#125;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"面试题","url":"/2023/11/01/00-%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"js面试题1.数据类型基本数据类型：string、number、布尔、undefined、null BigInt 更精准的数  Symbol 处理对象重复的key\n引用数据类型: 栈中存的是引用地址，值存在堆内存 object、array、function、RegExp、Date、Math  \n堆是先进先出 - 栈是先进后出\n\n2.转换方法Number()\n强制转换为数字 其他方法还有：在前加+ 、减-、乘*、除/\n规则：能转换成数字的优先转成数字，实在转不出来就转成NaN\n    Boolean()  转换布尔 显示转换 隐式转换  转换的规则：非空非0即为真\n    toString() 转换字符串 并不是用来转成字符串的，而是用来检测数据类型的 null和undefined不能用toString()转\n    isNaN() 判断是不是非数字 判断规则：判断之前先用Number()方法做隐式转换\n    判断规则：null只和undefined和它本身相等 其余的null、undefined不和任何值相等 判断之前有一个Number()方法的隐式转换\n\n3.对象解构赋值和数组解构赋值对象展开运算符\nlet obj = &#123;\nhello: &#39;hello&#39;,\nworld: &#39;world&#39;,\nname: &#39;Tim&#39;,\nage: 18\n&#125;\nlet &#123;hello, world, ...hi&#125; = obj;\n数组使用扩展运算符解构\nfunction f () &#123;\nreturn [&#39;hello&#39;, &#39;world&#39;, &#39;my&#39;, &#39;name&#39;, &#39;is Lilei&#39;];\n&#125;\nlet [hello, world, ...who] = f()\n\n4.js 获取 dom 的方法通过 ID 获取（getElementById）\n通过 name 属性（getElementsByName）\n通过标签名（getElementsByTagName）\n通过类名（getElementsByClassName）\n获取 html 的方法（document.documentElement）\n获取 body 的方法（document.body）\n通过 css 选择器获取一个元素（document.querySelector）\n通过选择器获取一组元素（document.querySelectorAll）\n\n5.获取和设置元素属性的方法元素.setAttribute(&#39;属性名&#39;,属性值) 设置元素的行间属性，如果原来有这个行间属性会覆盖原来的行间属性\n元素.getAttribute(&#39;属性名&#39;) 获取元素的行间属性对应的属性值，不能获取 css 样式对应的属性值 如果获取的属性不存在返回 null\ngetComputedStyle 获取经过浏览器计算后的属性 获取的结果是带单位的字符串\n\n6.js dom 元素方法1. 如何在 dom 元素前面添加元素（内部添加）\ndom.insertBefore(newDom,dom.firstChild)\n2. 如何在 dom 元素前面添加元素（外部添加）\ndom.parentNode.inserBefore(newDom,dom)\n3. 如何在 dom 元素后面添加元素(外部添加)\ndom.parentNode.insertBefore(newDom,dom.nextSibling)\n4. dom.appendChild(dom 元素)，元素尾部添加新元素（内部添加）\njs 有哪些动态添加 dom 元素的方法？\n-  parent.appendChild(newDom,existDom) 在 existDom 的前面添加新元素，parent 为 existDom 的父元素\njs 有哪些删除元素的方法\n1. dom.remove();自身调用 remove 删除\n2. parent.removeChild(child) 父元素删除子元素\n\n7.js 如何判断一个变量时 null&#x2F;undefined用==null 来判断是否为 undefined 或 null 值\n因为!null 为真，所以也可以简单的把判断语句改为！null 写法来同时判断 undefined 或 null 值\n\n8.js 判断是否为对象typeof:  主要用来检查基本数据类型\ninstanceof: 用于检测构造函数中的原型(prototype)属性是否出现在某个实例对象的原型链上\nconstructor: 用于检测实例对象是否是由某个构造函数实例化出来的\nobject.prototype.toString().call():检测对象的时候不用加call，别的数据类型必须用call，否则的话就变成了转成字符串的方法了\n\n9.new 关键字做了哪些事情？1.在堆内存中申请一块空间，创建一个新对象&#123;&#125;\n2.新对象的__proto__指向构造函数中的原型对象prototype\n3.确认this指向让上下文中this指向这个新对象\n4.执行构造函数中的代码 初始化新对象\n5.返回新对象 返回的是新对象的地址值 即便没有return 构造函数也会默认返回this\n\n10.字符串反转方式let newStr = str.split(&quot;&quot;).reverse().join(&quot;&quot;);\n\n11.jquery 的“$”有什么作用?可以把$换成其他的吗？$是JQuery常用的一个回传函数，定义为 “选取”，英文是 selector 的缩写\n\n$其实是 jQuery 的别称，而 jQuery 就是 jQuery 库提供的一个函数。    该函数可以根据 () 里的参数进行查找和选择 html 文档中的元素，()内不仅可以是 ID，还可以是各类选择器    可以替换，var jquery$ &#x3D; jQuery.noConflict();\n12.tcp 和 udp 区别他俩是什么？\n    是运输层的两种协议：\n        运输层就是负责向两台主机之间进行通信提供通用的数据传输服务，应用进程利用该服务传送应用层报文\nTCP 是面向连接的，UDP 是无连接的\nTCP 是可靠的，UDP 是不可靠的\nTCP 是面向字节流的，UDP 是面向数据报文的\nTCP 只支持点对点通信，UDP 支持一对一，一对多，多对多\nTCP 报文首部 20 个字节，UDP 首部 8 个字节\nTCP 有拥塞控制机制，UDP 没有\nTCP 协议下双方发送接受缓冲区都有，UDP 并无实际意义上的发送缓冲区，但是存在接受缓冲区\n\n13.ajax请求的五个步骤，创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。\n14.浏览器渲染过程将获取的 html 解析成 dom 树\n处理 css，构成层叠样式表模型 CSSOM（是对CSS样式表的对象化表示，同时还提供了相关API用来操作CSS样式）\n将 dom 树和 CSSOM 合并为渲染树\n根据 CSSOM 将渲染树的节点布局计算\n将渲染树节点样式绘制到页面上\n\n15.浅拷贝与深拷贝浅拷贝： 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用 \n方法：- Object.assign(目标对象，源对象)\n    - var obj1=&#123;&#125;\n        for(var key in obj)&#123;\n        obj1[key]=obj[key]\n        &#125;\n    - obj1=&#123;...obj&#125;;\n    - concat\n深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”\n方式：- 使用jq中的$.extend\n    - 用JSON.parse(JSON.stringify(你要复制的对象))\n    - 递归\n\n16. 统计字符串中每个字母出现的次数var obj=&#123;&#125;for(var i=0;i&lt;str.length;i++)&#123;    var key =str[i]    if(obj[key])&#123;        obj[key]++    &#125;else&#123;        obj[key]=1    &#125;&#125;for(var key i obj)&#123;    console.log(key+&#x27;出现了&#x27;+obj[key])&#125;\n17. 什么是 IIFE立即执行函数表达式：IIFE（Immediately-invoked function expression）\n总结 IFEE 的优点： 1.创建块级（私有）作用域，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突；\n2.IIFE 中定义的任何变量和函数，都会在执行结束时被销毁。这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了；\n\n18.如何改变this指向是函数的方法\ncall 传参只能传值 可以直接调用\napply 传参只能传数组 可以直接调用 应用场景：找出数组的最大值/最小值\nbind 只能传值 默认不能直接调用 应用场景：事件或者计时器里边修改this指向 \n\n19.如何阻止事件冒泡和默认事件event.stopPropagation()：阻止事件的冒泡方法\nevent.preventDefault()：阻止默认事件的方法\nreturn false：就等于同时调用了 event.stopPropagation()和 event.preventDefault()\n\n20.JavaScript 三大对象：本地对象、内置对象、宿主对象a.本地对象\n与宿主无关，无论在浏览器还是服务器中都有的对象，就是 ECMAScript 标准中定义的类(构造函数)\n在使用过程中需要我们手动 new 创建\n例如：Boolean、Number、String、Array、Function、Object、Date、RegExp 等\nb.内置对象\n与宿主无关，无论在浏览器还是服务器中都有的对象\nECMAScript 已经帮我们创建好的对象\n在使用过程中无需我们动手 new 创建\n例如：Global、Math、JSON\nc.宿主对象\n什么是宿主？\n宿主就是指 JavaScript 运行环境，js 可以在浏览器中运行，也可以在服务器上运行(nodejs)\n对于嵌入到网页中的 js 来说，其宿主对象就是浏览器，所以宿主对象就是浏览器提供的对象\n包含：Window 和 Docuument 等\n所有的 DOM 和 BOM 对象都属于宿主对象\n\n21.数组扁平化&#x2F;数组拉平- 用 ECMAscript 2019 中的 arr.flat(Infinity) 方法\n- 利用 arr.toString(），将数组转换为字符串\n再利用 str.split（‘ ，’），将字符串转换为新的数组\nmap遍历，parseInt（）每一项转数组\n- 使用 ES6 新增的扩展运算符\n- 递归  \n\n22.map,filter,for in 的区别map 则可以改变当前循环的值，返回一个新的被改变过值之后的数组（map 需 return）\nfilter 函数可以看成是一个过滤函数，返回符合条件的元素的数组\nfor…in 循环数组索引、对象的属性，但使用 for…in 原型链上的所有属性都将被访问，用 hasOwnProperty() 方法解决。map 方法有返回值，可以 return 出来\n\n23.js 中实例方法和原型方法的区别实例方法就是只有实例可以调用，静态方法只有构造函数可以调用，原型方法是实例和构造函数都可以调用，是共享的方法\n像Promise.all和Promise.race这些就是静态方法，Promise.prototype.then这些就是原型方法，new 出来的实例可以调用\n\n24.节流和防抖的区别防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于设置的时间，防抖的情况下只会调用一次，而节流的情况会每隔一定时间调用一次函数。\n\n25.浏览器内核  浏览器内核又可以分成两部分：渲染引擎和JS引擎\n  渲染引擎：负责获取网页的内容并显示，不同的浏览器内核对网页的解析渲染也不同\n  JS引擎：负责解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果\n  常用内核(内核种类很多)\n      常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit\n\n26.实现浏览器内多个标签页面之间通信一、cookie + setInterval 方式\n二、localStorage 方式\n三、webSocket 方式\n\n27.jQuery 对象与 DOM 对象的相互转化jq转dom    - 利用数组下标的方式读取 jQuery 中的 DOM 对象 var div &#x3D; $div[0]    - jQuery对象自身提供一个.get()方法允许我们直接访问jQuery对象中相关的DOM节点，get方法中提供了一个元素的索引var div &#x3D; $div.get(0)dom转jq    对象加工成一个 jQuery 对象。$(参数)是一个对功能大方法，通过传递不同的参数而产生不同的作用，    var div &#x3D; $(div)\n28.jQuery 获取的 dom 对象和原生的 dom 对象有何区别？js 原生获取的 dom 是一个对象，jQuery 对象就是一个数组对象，其实就是选择出来的元素的数组集合，所以说他们两者是不同的对象类型不等价。\n\n29.Jq 如何扩展自定义方法\\$.extend(&#123;\n　　 a:function ()&#123;\n　　　　 alert(&#39;I&#39; m lc&#39;);\n　　&#125;\n&#125;)\n\n30.jq 给所有元素加虚线\\$(&quot;\\*&quot;).css(&quot;border:2px dotted/dashed #000;&quot;)\n\n31.关于 jquery 的 load()方法jquery load 方法是对 jQuery.ajax()进行封装以方便我们使用的一个方法，当我们需要处理较为复杂的逻辑时候，还是需要用到 jQuery.ajax()这个比较全面的方法的。\nload()主要用来加载 header、footer、siderbar、tip(提示框/输入框)等多个公共组件，以及简单的调用动态接口。\n完整语法格式：load( url, [data], [callback] )\n参数:\nurl 是指要导入文件的地址。\ndata： 可选参数；因为 load 不仅仅可以导入静态的 html 文件，还可以导入动态脚本，例如 PHP 文件，所以要导入的是动态文件时，\n我们可以把要传递的参数放在这里。\ncallback：可选参数；是指调用 load 方法并得到服务器响应后，再执行的另外一个函数；回调参数：response, status, xhr\n\n$.ajax 方法url 表示请求的地址type 表示请求的类型 GET 或 POST 请求data 表示发送给服务器的数据格式有两种： 一：name&#x3D;value&amp;name&#x3D;value 二：{key:value}success 请求成功，响应的回调函数\n32.document.ready 和 window.onload 的区别页面加载完成有两种事件，一是 ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是 onload，指示页面包含图片等文件在内的所有元素都加载完成。\nready先加载，onload页面加载完之后加载\n\n33.瀑布流实现的原理瀑布流布局要求要进行布置的元素等宽，然后计算元素的宽度与浏览器宽度之比，得到需要布置的列数。\n创建一个数组，长度为列数，里面的值为已布置元素的总高度（最开始为 0）\n然后将未布置的元素依次布置到高度最小的那一列，就得到了瀑布流布局。\n\n34.lazyload 的实现原理图片可视 iscando 为 false，获取页面滚动高度，再判断图片是否在用户可视范围之内，如果在的话，将图片的 iscando 设为 true，声明一个 src 地址合集，当可视范围为 true 时，将 src 赋值给图片的 src 属性\n加载条件\nimg.offsetTop &lt; window.innerHeight + document.body.scrollTop;\nvar imgs = document.querySelectorAll(&#39;img&#39;);\nwindow.onscroll = function()&#123;\nvar scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\nvar winTop = window.innerHeight;\nfor(var i=0;i &lt; imgs.length;i++)&#123;\nif(imgs[i].offsetTop &lt; scrollTop + winTop )&#123;\nimgs[i].src = imgs[i].getAttribute(&#39;data-src&#39;);\n&#125;\n&#125;\n&#125;\n实现性能提高需要将节流和懒加载一起使用\n\n35.Array 与 ArrayBuffer 的区别ArrayBuffer 只能定义长度，无法直接读取它的内容\n每个 ArrayBuffer 对象表示的只是内存中指定的字节数;\n但不会指定这些字节用于保存什么类型的数据；\n通过 ArrayBuffer 能做的，就是为了将来使用而分配一定数量的字节.\n\n36.js 在浏览器兼容有那些问题HTML 对象获取问题\nFireFox：document.getElementById(“idName”);\nie:document.idname 或者 document.getElementById(“idName”).\n自定义属性问题\nIE 下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性；Firefox 下，只能使用 getAttribute() 获取自定义属性。\n解决方法：统一通过 getAttribute() 获取自定义属性。\n\n37.document.write()和 innerHTML 的区别document.write 是重写整个 document, 写入内容是字符串的 html，会导致页面全部重绘\ninnerHTML 是 HTMLElement 的属性，是一个元素的内部 html 内容，不会导致页面全部重绘\n\n38.JavaScript 中的作用域、作用域链作用域的本质是一个保存变量的对象，作用域避免了不同范围内的数据的相互干扰。\n变量的作用域无非就是两种：全局变量和局部变量。\n全局作用域：\n最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的：\n局部作用域：\n和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部\n作用域链是由多级作用域串联形成的链式结构\n根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问。将会按照作用域链一级级向上寻找搜索\n延长作用域链就是在作用域链的前端增加一个变量对象。“with语句”\n\n39.为什么异步加载 js ，加载方式异步加载是立即下载 js 脚本的同时又不妨碍页面中的其他操作。\ndefer：规定是否对脚本执行进行延迟，但却是并行下载，要等到 DOM 文档全部加载解析好了，才会被执行。只有 IE 能用，也可以将代码写到内部\n&lt;script type=&quot;text/javascript&quot; src=&quot;demo.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;\n\nasync：异步加载，加载好了就执行，不管页面是否解析好。async 只能加载外部脚本，不能把 js 写在 script 标签里(IE9 以上都能执行，比较普遍)\n动态创建 script 标签插入到 dom 元素中\n\n40.js 面向对象的继承方法1、通过改变原型的指向实现继承\n2、借用父级构造函数实例继承(通过call修改this指向)\n3、组合继承\n原型继承，混合继承\n\n41.重绘和重排重绘是一个元素外观的改变导致的浏览器行为（例如改变 visibility，outline，background 等属性），浏览器会根据元素新的属性呈现新的外观；\n重排是 DOM 元素被 js 触发某种变化，渲染树需要重新计算。浏览器对 DOM 树进行重新排列；这便是重排。排列完成之后重新绘制元素则是重绘。\n\n42.js 去除空格str.replace(/\\s+/g,&quot;&quot;);\n\n43.使用 es5 语法，如何将一个类似数组的对象转换为数组？（比如 document.getElementsByTagName(…)的返回值）Array.prototype.slice.call(document.getElementsByTagName(...))\n\n44.js 如何判读一个对象是否为空对象for in 遍历这个对象，如果有值的话，就不是空，否则就是空\n  var obj = &#123;&#125;;\n  var b = function() &#123;\n  for(var key in obj) &#123;\n  return false;\n  &#125;\n  return true;\n  &#125;\n  将对象转化为 json 字符串，再判断该字符串是否为&quot;&#123;&#125;&quot;\n  var data = &#123;&#125;;\n  var b = (JSON.stringify(data) == &quot;&#123;&#125;&quot;);\n  alert(b);\n\n45.dom 元素上的 property 和 attribute 的区别  对属性 Property 可以赋任何类型的值，而对特性 Attribute 只能赋值字符串！\n  对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的\n  但是对于自定义的属性来说，他们是不同步的.(自定义属性不会自动添加到 property)\n  1.property 能够从 attribute 中得到同步；\n  2.attribute 不会同步 property 上的值；\n\n46.js 控制循环的方法  break\n  终止循环\n  跳出本层循环，继续执行循环后面的语句。\n  如果循环有多层，则 break 只能跳出一层\n  continue\n  跳过本次循环剩余的代码，继续执行下一次循环。\n\n47.斐波那契  function Fibonacci(n)&#123;\n  if(n == 1 || n == 2)&#123;\n  return 1;\n  &#125;\n  else&#123;\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\n  &#125;\n  &#125;\n\n48.事件冒泡  事件冒泡：当某个元素的某类型事件被触发时（如 onclick），它父级的同类型事件也会被触发，它的父级的父级同类型事件也会被触发，以此类推，一直触发到根元素。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。\n  事件冒泡有下到上，事件捕获有上到下\n\n49.JavaScript 的同源策略  同源：协议、域名、端口全部相同才是同源，考虑到安全性，不同源之间不能够进行数据通信\n\n50.url组成http:/https: 协议\nwww.baidu.com 域名\n:8080 端口\n/sf/vsearch 路径\n?wd=百度热搜 查询(可有可无)\n#a=1&amp;b=2 哈希值(可有可无)\n\n51.for in 和 for of 循环的区别 ?`for in` 用于遍历对象的键(`key`)，`for in`会遍历所有自身的和原型链上的可枚举属性。如果是数组，\n\nfor in会将数组的索引(index)当做对象的key来遍历，其他的object也是一样的。    for of是es6引入的语法，用于遍历 所有迭代器iterator，其中包括HTMLCollection,NodeList,Array，Map，Set，String，TypedArray，arguments等对象的值(item)\n52.url请求过程    DNS 解析:将域名地址解析成 IP 地址\n    TCP 连接：TCP 三次握手\n    处理请求：发送请求\n    接收响应：响应报文\n    渲染页面：浏\n    断开连接：四次挥手\n\n53.10-50的随机数- Math.floor(Math.random()*39)+10\n- Math.ceil(Math.random()*40)+10\n\n54.获取时间var date = new Date();\n    var year = date.getFullYear();    //  返回的是年份\n    var month = date.getMonth() + 1;  //  返回的月份上个月的月份，记得+1才是当月\n    var dates = date.getDate();       //  返回的是几号\n    var day = date.getDay();          //  周一返回的是1，周六是6，但是周日是0\n\n55.性能优化减少请求数量、使用缓存、减少资源大小、精灵图\n\n56.eval()的作用eval()可以接受一个字符串str作为参数，并把这个参数作为脚本代码来执行。    eval(string) 函数计算 JavaScript 字符串，并把它作为脚本代码来执行    如果参数是一个表达式，eval() 函数将执行表达式；    如果参数是Javascript语句，eval()将执行 Javascript 语句；    如果执行结果是一个值就返回，不是就返回undefined，如果参数不是一个字符串，则直接返回该参数。    特殊：eval(“{b:2}”) &#x2F;&#x2F; 声明一个对象    eval(“（{b:2}）”) &#x2F;&#x2F; 返回对象{b:2}\nFunction和eval有什么区别？共同点：都可以将字符串转化为js代码不同点：Function创建出来的函数并不会直接调用，只有当手动去调用创建出来的函数的时候才调用，eval把字符串转化为代码后，直接就执行了。\n57.本地存储- localStorage、sessionStorage、cookie三者的区别\n存储大小\n    cookie数据大小不能超过4k ；\n    sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大；\n有效时间\n    localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n    sessionStorage 数据在当前浏览器窗口关闭后自动删除；\n    cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭；\n数据与服务器之间的交互方式\n    cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端；\n    sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存；\n\n58.会话cookie 持久cookie- 如果 cookie 不包含到期日期，则可视为会话 cookie\n    - 会话 cookie 存储在内存中，决不会写入磁盘。 当浏览器关闭时，cookie 将从此永久丢失。\n- 如果 cookie 包含到期日期，则可视为持久性 cookie。\n    -  在指定的到期日期，cookie 将从磁盘中删除。\n\n59.cookie替代localStorage、sessionStorage\n\n60.if有作用域吗只有函数有作用域，if是没有作用域的。\n但是有一种情况会让if看上去有作用域，就是在if &#123;&#125;语句中，使用const、let，他们会有块级作用域。\n\n61.promise- promise是解决异步的方法\n    - Promise对象有两个特点：\n        - 1）对象的状态不受外界的影响。\n        - 2）状态一旦改变，便不会再次改变。而且它的状态改变只会由（pending-&gt;fulfilled、pending-&gt;rejected）并且这两种情况只要发生其中一个，状态便固定了。\n- Promise的优点：\n    - 支持链式调用（可以将异步操作以同步的方式显示出来）避免回调地狱\n        - 什么是回调地狱？\n            - 多个回调函数层层嵌套，外层回调函数异步返回的结果是内层回调函数执行的条件\n        - 回调地狱的缺点？\n            - 1、可读性、可维护性差\n            - 不便于异常处理\n        - 什么是回调函数？\n            - 函数被当做参数被传给另外一个函数\n\n62.async&#x2F;awaitasync用来修饰function，async返回promise，await写在async里面，await后面是promise\n在async函数中await的作用是把promise作为同步执行\n\n63.什么是闭包？\n内层函数可有访问外层函数和变量\n内层函数对外层函数的活动变量进行访问\n内层函数执行、创建上下文，此时就形成了闭包 &#x3D;》 闭包就是一个环境 一句话概括： 或者说：闭包就是可以访问其他函数内部数据的函数 或者说：当一个嵌套的内部（子）函数引用了嵌套外部（父）函数的变量（函数时）内部（子）函数执行就产生了闭包\n闭包的好处：延长作用域链、缓存数据、避免全局污染  闭包应用：      让函数外部可以操作函数内部的数据、定义S模块      具有特定功能的js文件，将所有的数据和功能都封装在一个函数内部（私有的）      只向外部暴露一个包含n个方法的对象或函数      模块的使用者，只需要通过没看暴露的对象调用\n\n闭包的缺点：      容易造成内存泄漏      常见的js内存泄漏陷阱：闭包、遗漏的定时器、定义过多的全局变量\n\n什么叫内存溢出：      指程序申请内存时，没有足够的内存提供申请者使用，导致数据无法正常存储到内存中\n\n什么叫内存泄漏：      是指程序在申请内存后，无法释放已申请的内存空间，导致系统无法及时回收内存并且分配给其他进程使用。      通常少次数的内存无法及时回收并且不会得到程序造成什么影响，但是如果在内存本身就比较少获取多次导致内存      无法正常回收时，就会导致内存不够用，最终导致内存溢出。\n\n\n\n\n64.webpack 的 bundle，chunk，module 的意思module 是 webpack 支持解析的模块；\nchunk 包含多个 module，存在于 webpack 处理过程中的阶段；\nbundle 包含一个或多个 chunk，是源码经过 webpack 处理后的最终版本；\n\n65.webpack性能优化打包公共代码\n动态导入和按需加载\n删除无用的代码\n长缓存优化\n公共代码内联\n\n66.webpack 的 bundle，chunk，module 的意思module 是 webpack 支持解析的模块；\nchunk 包含多个 module，存在于 webpack 处理过程中的阶段；\nbundle 包含一个或多个 chunk，是源码经过 webpack 处理后的最终版本；\n\n67.lazyload的实现原理将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求。可以指向loading的地址。注：图片要指定宽高当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。\n68.this指向- 对象中的this指向当前对象\n- 默认情况下指向window\n- 自执行函数中this指向window\n- 计时器中this指向window\n- 事件中的this指向事件源\n- 箭头函数中的this指向上一层的范围\n- 构造函数中的this指向构造函数实例\n\n69.什么是原型链？访问属性时，从对象自身沿着__proto__指向，一直到Object.prototype,形成一个链式结构(访问属性时就近原则)\n\n70.原型对象只要声明函数，系统自动产生一个对象，就叫原型对象\n存放所有实例对象需要数据共享(属性或者方法)节省了内存空间 避免了全局污染 \n\n71.为什么写在原型上的方法或者属性，实例对象会自动继承？所有的对象都有一个属性__proto__\n因为：原型对象的constructor和实例对象中constructor指向同一个\n\n72.实例是如何访问到constructor属性的实例通过proto访问到构造函数原型，构造函数原型的constructor=构造函数\n\n73.原型对象 、实例对象 、 构造函数三者之间的关系1、实例对象是有构造函数实例化出来的\n2、构造函数中有一个prototype属性 指向的是prototy原型对象\n    在原型对象上有一个constructor属性 他指向是构造器 该构造器表示的是原型所在的构造函数\n3、实例对象中有一个__proto__属性，指向的是实例对象的构造函数中的prototype原型对象\n\n74.普通函数和构造函数有哪些区别？构造函数用new fn()    普通函数fn()\nthis指向实例\tthis指向window\n默认返回实例，return引用类型生效，return基本类型无效\n普通函数默认返回undefined，return生效\n\nAJAX1. ajax请求的五个步骤，创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。## 流程：创建xhrvar xhr=new XMLHTTPRequest()侦听通信状态改变的事件xhr.addEventListener(&quot;readystatechange&quot;,    readyStateChangeHandler);Method 分为 get post put delete等等Async 异步同步name和password是用户名和密码xhr.open(Method,URL,Async,name,password)发送内容给服务器xhr.send(内容)function readyStateChangeHandler(e)&#123;当状态是4时，并且响应头成功200时，if(xhr.readyState===4 &amp;&amp; xhr.status===200)&#123;打印返回的消息console.log(xhr.response)# 2.ajax同步和异步的区别    同步的请求的时候，代码好比在排队，必须是一个挨着一个的去执行，前面的没有结束，后面的代码就处于一个阻塞的状态。异步执行的时候，数据请求的同时，其他代码语句也可以同步执行，比如，在数据请求的时候，由于某些愿意，需要慢慢的返回请求结果，在这个时候带宽是很空闲的，那么，代码不会等到前面的数据完全请求返回就可以开始后面的代码运行。# 3.ajax 获取数据    请求方式：        get：获取数据        post：向服务器推送数据        put：给服务器上增加资源（上传图片）        delete: 删除资源,向服务器传输内容方式与get一致        head：获取服务器的响应头信息,向服务器传输内容方式与get一致    传参方式        get：直接拼接路径后面 url&#x2F;?name&#x3D;lis&amp;age&#x3D;20        psot：传参必须要写请求头  目的：为了传递解析好的数据 设置完在传递              (1) xhr.setRequestHeader(‘Content-Type’,”application&#x2F;x-www-form-urlencoded”)                  xhr.send(“name&#x3D;lis&amp;age&#x3D;20”)              (2) xhr.setRequestHeader(‘Content-Type’,”application&#x2F;json”)                  xhr.send(“{name:aa,age:111}”)# 4.有封装过 axios 吗？怎么封装的？     axios 是一个轻量的 HTTP 客户端    基于 XMLHttpRequest 服务来执行 HTTP 请求，支持丰富的配置，支持 Promise，支持浏览器端和 Node.js 端    axios 的请求是使用 Promise 来实现 XMLHttpRequset 的，promise 本身就是一个异步的处理的方案，所以 axios 是异步的封装的同时，你需要和后端协商好一些约定，请求头，状态码，请求超时时间…\n设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分\n请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)\n状态码: 根据接口返回的不同 status ， 来执行不同的业务，这块需要和后端约定好\n请求方法：根据 get、post 等方法进行一个再次封装，使用起来更为方便\n请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问\n响应拦截器：这块就是根据 后端`返回来的状态码判定执行不同业务\n\n5.ajax状态码0. 请求未初始化\n1. 发起请求建立连接\n2. 接受请求\n3. 解析服务器\n4. 请求成功\n\n6.什么是跨域？   所谓跨域 不是请求未发送 而是请求发起成功 服务器接收成功、并且服务器将数据响应给了浏览器 浏览器对数据做了拦截\n\n   为什么会产生跨域？       项目发布的时候不同的功能发布在不同的服务器上       同源策略： 协议、域名、端口不一致就跨域\n7.如何解决跨域（1）后端设置请求头 res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)\n       或者设置白名单 \n           let whiteList = [&#39;http://127.0.0.1:5500&#39;]\n           if(whiteList.includes(req.headers.origin))&#123;\n             res.setHeader(&#39;Access-Control-Allow-Origin&#39;, req.headers.origin)\n           &#125;\n（2）后端用插件 \n    const cors = require(&#39;cors&#39;)  app.use(cors())\n（3）用json的原理\n    JSONP 是一种非正式传输协议，可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，\n   - 当GET请求从后台页面返回时，可以返回一段JavaScript代码，这段代码会自动执行，可以用来负责调用后台页面中的一个callback函数。然后服务端返回数据时会将这个callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。\n\n8.状态码        1**：请求收到，继续处理\n        2**：操作成功收到，分析、接受\n        3**：完成此请求必须进一步处理\n        4**：请求包含一个错误语法或不能完成\n        5**：服务器执行一个完全有效请求失败\n\n        100——客户必须继续发出请求\n        101——客户要求服务器根据请求转换HTTP协议版本\n\n        200——交易成功\n        201——提示知道新文件的URL\n        202——接受和处理、但处理未完成\n        203——返回信息不确定或不完整\n        204——请求收到，但返回信息为空\n        205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件\n        206——服务器已经完成了部分用户的GET请求\n\n\n        300——请求的资源可在多处得到\n        301——删除请求数据\n        302——在其他地址发现了请求数据\n        303——建议客户访问其他URL或访问方式\n        304——客户端已经执行了GET，但文件未变化\n        305——请求的资源必须从服务器指定的地址得到\n        306——前一版本HTTP中使用的代码，现行版本中不再使用\n        307——申明请求的资源临时性删除\n\n\n        400——错误请求，如语法错误\n        401——请求授权失败\n        402——保留有效ChargeTo头响应\n        403——请求不允许\n        404——没有发现文件、查询或URl\n        405——用户在Request-Line字段定义的方法不允许\n        406——根据用户发送的Accept拖，请求资源不可访问\n        407——类似401，用户必须首先在代理服务器上得到授权\n        408——客户端没有在用户指定的饿时间内完成请求\n        409——对当前资源状态，请求不能完成\n        410——服务器上不再有此资源且无进一步的参考地址\n        411——服务器拒绝用户定义的Content-Length属性请求\n        412——一个或多个请求头字段在当前请求中错误\n        413——请求的资源大于服务器允许的大小\n        414——请求的资源URL长于服务器允许的长度\n        415——请求资源不支持请求项目格式\n        416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段\n        417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求\n\n        \n        500——服务器产生内部错误\n        501——服务器不支持请求的函数\n        502——服务器暂时不可用，有时是为了防止发生系统过载\n        503——服务器过载或暂停维修\n        504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长\n        505——服务器不支持或拒绝支请求头中指定的HTTP版本\n\n"},{"title":"浏览器工作原理","url":"/2023/10/31/01-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","content":"浏览器工作原理浏览器的组成\n人机交互部分（UI）\n网络请求部分（Socket）\nJavaScript引擎部分（解析执行JavaScript）\n渲染引擎部分（渲染HTML、CSS等）\n数据存储部分（cookie、HTML5中的本地存储LocalStorage、SessionStorage）\n\n主流渲染引擎介绍\n渲染引擎 又叫 排版引擎 或 浏览器内核。\n\n主流的 渲染引擎 有\n\n\n\nChrome浏览器: Blink引擎（WebKit的一个分支）。\nSafari浏览器: WebKit引擎，windows版本2008年3月18日推出正式版，但苹果已于2012年7月25日停止开发Windows版的Safari。\nFireFox浏览器: Gecko引擎。\nOpera浏览器: Blink引擎(早期版使用Presto引擎）。\nInternet Explorer浏览器: Trident引擎。\nMicrosoft Edge浏览器: EdgeHTML引擎（Trident的一个分支）。\n\n工作原理\n解析HTML构建Dom树（Document Object Model，文档对象模型），DOM 是W3C组织推荐的处理可扩展置标语言的标准编程接口。\n\n构建渲染树，渲染树并不等同于Dom树，因为像head标签 或 display: none这样的元素就没有必要放到渲染树中了，但是它们在Dom树中。\n\n对渲染树进行布局，定位坐标和大小、确定是否换行、确定position、overflow、z-index等等，这个过程叫&quot;layout&quot; 或 &quot;reflow&quot;。\n\n绘制渲染树，调用操作系统底层API进行绘图操作。\n\n\n渲染引擎工作原理示意图渲染引擎工作原理示意图\n\nWebKit工作原理（Chrome、Safari、Opera）\n\nGecko工作原理（FireFox）\n\n浏览器的 reflow 或 layout 过程https://www.youtube.com/watch?v=ZTnIxIA5KGw\n打开 Chrome 的 Rendering 功能第一步：\n\n第二步：\n\n浏览器访问网站过程\n\n在浏览器地址栏中输入网址。\n\n\n\n\n\n浏览器通过用户在地址栏中输入的URL构建HTTP请求报文。\n\n\nGET / HTTP/1.1Host: www.taobao.comConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, sdch, brAccept-Language: zh-CN,zh;q=0.8,en;q=0.6Cookie: l=Ag0NWp9E8X4hgaGEtIBhOmKxnSOH6kG8; isg=AkZGLTL-Yr9tHDZbgd5bsn4Rlzwg5IphaK-1BzBvMmlEM-ZNmDfacSyDfdgF; thw=cn\n\n\n\n浏览器发起DNS解析请求，将域名转换为IP地址。\n\n\n\n\n\n浏览器将请求报文发送给服务器。\n\n\n\n\n服务器接收请求报文（request），并解析。\n\n\n\n\n服务器处理用户请求，并将处理结果封装成HTTP响应报文（response）。\n\n\nHTTP/1.1 200 OKServer: TengineDate: Thu, 13 Apr 2017 02:24:25 GMTContent-Type: text/html; charset=utf-8Transfer-Encoding: chunkedConnection: keep-aliveVary: Accept-EncodingVary: Ali-Detector-Type, X-CIP-PTCache-Control: max-age=0, s-maxage=300Via: cache8.l2cm10-1[172,200-0,C], cache13.l2cm10-1[122,0], cache3.cn206[0,200-0,H], cache6.cn206[0,0]Age: 293X-Cache: HIT TCP_MEM_HIT dirn:-2:-2X-Swift-SaveTime: Thu, 13 Apr 2017 02:19:32 GMTX-Swift-CacheTime: 300Timing-Allow-Origin: *EagleId: 9903e7e514920502659594264eStrict-Transport-Security: max-age=31536000Content-Encoding: gzip&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot; /&gt;&lt;title&gt;淘宝网 - 淘！我喜欢&lt;/title&gt;&lt;meta name=&quot;spm-id&quot; content=&quot;a21bo&quot; /&gt;&lt;meta name=&quot;description&quot; content=&quot;淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！&quot; /&gt;&lt;meta name=&quot;aplus-xplug&quot; content=&quot;NONE&quot;&gt;&lt;meta name=&quot;keyword&quot; content=&quot;淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺&quot; /&gt;&lt;/head&gt;&lt;body&gt;\t......&lt;/body&gt;&lt;/html&gt;\n\n\n\n服务器将HTTP响应报文发送给浏览器。\n\n\n\n\n浏览器接收服务器响应的HTTP报文，并解析。\n\n\n\n\n浏览器解析 HTML 页面并展示，在解析HTML页面时遇到新的资源需要再次发起请求。\n\n\n\n\n最终浏览器展示出了页面\n\n\nHTTP请求报文和响应报文格式\nDNS 解析过程\nwindows 下 hosts 文件位置C:\\Windows\\System32\\drivers\\etc\\hosts\nDOM 解析参考代码:\n&lt;html&gt;  &lt;body&gt;    &lt;p&gt;Hello World&lt;/p&gt;    &lt;div&gt; &lt;img src=&quot;example.png&quot; alt=&quot;example&quot;/&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\nWebkit CSS 解析\nHow Browsers work - 浏览器是如何工作的How Browsers workhttps://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\n"},{"title":"Web开发本质","url":"/2023/10/31/05-Web%E5%BC%80%E5%8F%91%E6%9C%AC%E8%B4%A8/","content":"Web开发本质牢记以下三点\n请求，客户端发起请求。\n处理，服务器处理请求。\n响应，服务器将处理结果发送给客户端\n\n对比一个单机版计算器和Web版计算器客户端处理响应\n服务器响应完毕后，客户端继续处理：\n浏览器：解析服务器返回的数据\niOS、Android 客户端，解析服务器返回的数据，并且通过iOS或Android的UI技术实现界面的展示功能\n\n\n\n关于 C&#x2F;S（Client&#x2F;Server） 和 B&#x2F;S（Browser&#x2F;Server）C&#x2F;S: 客户端服务器\nB&#x2F;S: 浏览器服务器\n\n"}]