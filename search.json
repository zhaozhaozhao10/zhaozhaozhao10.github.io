[{"title":"浏览器工作原理","url":"/2023/10/31/00-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","content":"浏览器工作原理浏览器的组成\n人机交互部分（UI）\n网络请求部分（Socket）\nJavaScript引擎部分（解析执行JavaScript）\n渲染引擎部分（渲染HTML、CSS等）\n数据存储部分（cookie、HTML5中的本地存储LocalStorage、SessionStorage）\n\n主流渲染引擎介绍\n渲染引擎 又叫 排版引擎 或 浏览器内核。\n\n主流的 渲染引擎 有\n\n\n\nChrome浏览器: Blink引擎（WebKit的一个分支）。\nSafari浏览器: WebKit引擎，windows版本2008年3月18日推出正式版，但苹果已于2012年7月25日停止开发Windows版的Safari。\nFireFox浏览器: Gecko引擎。\nOpera浏览器: Blink引擎(早期版使用Presto引擎）。\nInternet Explorer浏览器: Trident引擎。\nMicrosoft Edge浏览器: EdgeHTML引擎（Trident的一个分支）。\n\n工作原理\n解析HTML构建Dom树（Document Object Model，文档对象模型），DOM 是W3C组织推荐的处理可扩展置标语言的标准编程接口。\n\n构建渲染树，渲染树并不等同于Dom树，因为像head标签 或 display: none这样的元素就没有必要放到渲染树中了，但是它们在Dom树中。\n\n对渲染树进行布局，定位坐标和大小、确定是否换行、确定position、overflow、z-index等等，这个过程叫&quot;layout&quot; 或 &quot;reflow&quot;。\n\n绘制渲染树，调用操作系统底层API进行绘图操作。\n\n\n渲染引擎工作原理示意图渲染引擎工作原理示意图\n\nWebKit工作原理（Chrome、Safari、Opera）\n\nGecko工作原理（FireFox）\n\n浏览器的 reflow 或 layout 过程https://www.youtube.com/watch?v=ZTnIxIA5KGw\n打开 Chrome 的 Rendering 功能第一步：\n\n第二步：\n\n浏览器访问网站过程\n\n在浏览器地址栏中输入网址。\n\n\n\n\n\n浏览器通过用户在地址栏中输入的URL构建HTTP请求报文。\n\n\nGET / HTTP/1.1Host: www.taobao.comConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, sdch, brAccept-Language: zh-CN,zh;q=0.8,en;q=0.6Cookie: l=Ag0NWp9E8X4hgaGEtIBhOmKxnSOH6kG8; isg=AkZGLTL-Yr9tHDZbgd5bsn4Rlzwg5IphaK-1BzBvMmlEM-ZNmDfacSyDfdgF; thw=cn\n\n\n\n浏览器发起DNS解析请求，将域名转换为IP地址。\n\n\n\n\n\n浏览器将请求报文发送给服务器。\n\n\n\n\n服务器接收请求报文（request），并解析。\n\n\n\n\n服务器处理用户请求，并将处理结果封装成HTTP响应报文（response）。\n\n\nHTTP/1.1 200 OKServer: TengineDate: Thu, 13 Apr 2017 02:24:25 GMTContent-Type: text/html; charset=utf-8Transfer-Encoding: chunkedConnection: keep-aliveVary: Accept-EncodingVary: Ali-Detector-Type, X-CIP-PTCache-Control: max-age=0, s-maxage=300Via: cache8.l2cm10-1[172,200-0,C], cache13.l2cm10-1[122,0], cache3.cn206[0,200-0,H], cache6.cn206[0,0]Age: 293X-Cache: HIT TCP_MEM_HIT dirn:-2:-2X-Swift-SaveTime: Thu, 13 Apr 2017 02:19:32 GMTX-Swift-CacheTime: 300Timing-Allow-Origin: *EagleId: 9903e7e514920502659594264eStrict-Transport-Security: max-age=31536000Content-Encoding: gzip&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot; /&gt;&lt;title&gt;淘宝网 - 淘！我喜欢&lt;/title&gt;&lt;meta name=&quot;spm-id&quot; content=&quot;a21bo&quot; /&gt;&lt;meta name=&quot;description&quot; content=&quot;淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！&quot; /&gt;&lt;meta name=&quot;aplus-xplug&quot; content=&quot;NONE&quot;&gt;&lt;meta name=&quot;keyword&quot; content=&quot;淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺&quot; /&gt;&lt;/head&gt;&lt;body&gt;\t......&lt;/body&gt;&lt;/html&gt;\n\n\n\n服务器将HTTP响应报文发送给浏览器。\n\n\n\n\n浏览器接收服务器响应的HTTP报文，并解析。\n\n\n\n\n浏览器解析 HTML 页面并展示，在解析HTML页面时遇到新的资源需要再次发起请求。\n\n\n\n\n最终浏览器展示出了页面\n\n\nHTTP请求报文和响应报文格式\nDNS 解析过程\nwindows 下 hosts 文件位置C:\\Windows\\System32\\drivers\\etc\\hosts\nDOM 解析参考代码:\n&lt;html&gt;  &lt;body&gt;    &lt;p&gt;Hello World&lt;/p&gt;    &lt;div&gt; &lt;img src=&quot;example.png&quot; alt=&quot;example&quot;/&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\nWebkit CSS 解析\nHow Browsers work - 浏览器是如何工作的How Browsers workhttps://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\n"},{"title":"node.js","url":"/2023/10/31/02-node.js%E4%BB%8B%E7%BB%8D/","content":"node.js 介绍node.js 是什么？\nnode.js 是一个开发平台，就像Java开发平台、.Net开发平台、PHP开发平台、Apple开发平台一样。\n\n\n何为开发平台？有对应的编程语言、有语言运行时、有能实现特定功能的API（SDK：Software Development Kit）\n\n\nnodejs平台使用的编程语言是 JavaScript 语言。 \n不支持 window、document、bom 对象。\n\n\nnode.js 平台是基于 Chrome V8 JavaScript 引擎构建。\n基于 node.js 可以开发控制台程序（命令行程序、CLI程序）、桌面应用程序（GUI）、（借助 node-webkit、electron 等框架实现）、Web 应用程序（网站）。\n\nPHP开发技术栈: LAMP - Linux Apache MySQL PHP\nnode.js 全栈开发技术栈: MEAN - MongoDB Express Angular Node.js\nnode.js 有哪些特点？\n事件驱动(当事件被触发时，执行传递过去的回调函数)\n非阻塞 I&#x2F;O 模型（当执行I&#x2F;O操作时，不会阻塞线程）\n单线程\n拥有世界最大的开源库生态系统 —— npm。\n\nnode.js 网站\nnode.js官方网站\nnode.js中文网\nnode.js 中文社区\n\n为什么要学习Node.js?\n通过学习Node.js开发深入理解服务器开发、Web请求和响应过程、 了解服务器端如何与客户端配合\n学习服务器端渲染：art-template、ejs、jsp\n学习服务器端为客户端编写接口\n现在前端工程师面试，对 Node.js 开发有要求\n补充提问：\n\n\n在Node.js平台开发时，能使用Dom API吗？比如：document.getElementById(&#39;id&#39;); window.location 等?\n\n\n复习 浏览器端 JavaScript 组成：ECMAscript、Dom、Bom\n\n学习目标\n了解服务器开发过程\n\n会使用 node.js 开发基本的 http 服务程序（Web应用程序）\n\n\nNode.js可以用来做什么？\n具有复杂逻辑的动态网站 \nWebSocket服务器 \n命令行工具 \n带有图形界面的本地应用程序 \n……\n\n终端基本使用打开应用\nnotepad 打开记事本\nmspaint 打开画图\ncalc 打开计算机\nwrite 写字板\nsysdm.cpl 打开环境变量设置窗口\n\n常用命令\nmd 创建目录\nrmdir(rd) 删除目录，目录内没有文档\necho on a.txt 创建空文件\ndel 删除文件\nrm 文件名 删除文件\n\nNode.js开发环境准备\n普通安装方式官方网站\n\n多版本安装方式  centOS  ubuntu\n\n卸载已有的Node.js\n下载nvm\n在C盘创建目录dev\n在dev目中中创建两个子目录nvm和nodejs\n并且把nvm包解压进去nvm目录中\n在install.cmd文件上面右键选择【以管理员身份运行】\n打开的cmd窗口直接回车会生成一个settings.txt文件，修改文件中配置信息\n配置nvm和Node.js环境变量\nNVM_HOME:C:\\dev\\nvm\nNVM_SYMLINK:C:\\dev\\nodejs\n\n\n把配置好的两个环境变量加到Path中\n\n\n\nnvm常用的命令\nnvm list 查看当前安装的Node.js所有版本\nnvm install 版本号 安装指定版本的Node.js\nnvm uninstall 版本号 卸载指定版本的Node.js\nnvm use 版本号 选择指定版本的Node.js\n\nNode.js之HelloWorld\n命令行方式REPL\n运行文件方式\n全局对象概览\n\nNode.js 开发 Web 应用程序 和 PHP、Java、ASP.Net等传统模式开发Web应用程序区别\n传统模式\n\n\n有 Web 容器\n\n\nNode.js开发Web应用程序\n\n\n没有 Web 容器\n\n \n\n补充提问：\n\n\n什么是动态网页？什么是静态网页？\n\n在 node.js 上编写程序REPL介绍\nREPL 全称: Read-Eval-Print-Loop（交互式解释器）\n\n\nR 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。\nE 执行 - 执行输入的数据结构\nP 打印 - 输出结果\nL 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。\n\n\n在REPL中编写程序 （类似于浏览器开发人员工具中的控制台功能）\n\n\n直接在控制台输入 node 命令进入 REPL 环境\n\n\n按两次 Control + C 退出REPL界面 或者 输入 .exit 退出 REPL 界面\n\n\n按住 control 键不要放开, 然后按两下 c 键\n\n创建 JavaScript 文件编写程序JavaScript 文件名命名规则\n不要用中文\n不要包含空格\n不要出现node关键字，比如：node.js\n建议以 ‘-‘ 分割单词\n\n案例\n案例1：编写一个简单的函数, 实现数字相加\n\nvar n = 10;var m = 100;function add(x, y) &#123;  return x + y;&#125;var result = add(m, n);console.log(&#x27;计算结果是：&#x27; + result);\n\n\n\n\n案例：文件读写案例\n\n\n使用到的模块var fs = require(&#39;fs&#39;);\n\n1、写文件：fs.writeFile(file, data[, options], callback);\n\n参数1：要写入的文件路径，必填。\n参数2：要写入的数据，必填。\n参数3：写入文件时的选项，比如：文件编码，选填。\n参数4：文件写入完毕后的回调函数，必填。\n写文件注意：\n该操作采用异步执行\n如果文件已经存在则替换掉\n默认写入的文件编码为utf8\n回调函数有1个参数：err，表示在写入文件的操作过程中是否出错了。\n如果出错了err != null，否则 err === null\n\n\n\n\n\n\n2、读文件：fs.readFile(file[, options], callback)\n\n参数1：要读取的文件路径，必填。\n参数2：读取文件时的选项，比如：文件编码。选填。\n参数3：文件读取完毕后的回调函数，必填。\n读文件注意：\n该操作采用异步执行\n回调函数有两个参数，分别是err和data\n如果读取文件时没有指定编码，那么返回的将是原生的二进制数据；如果指定了编码，那么会根据指定的编码返回对应的字符串数据。\n\n\n\n\n注意：\n\n文件操作中的./表示当前路径，相对的是执行node命令的路径，而不是当前被执行的*.js文件的实际路径。\n__dirname才永远表示当前被执行的*.js文件的实际路径\n/表示根目录, 读取文件或写入文件的时候写/目录，在Windows下相当于当前磁盘根目录（比如：c:\\ 或 d:\\ 或 e:\\  等，在Mac下相当于硬盘根目录 /）\n\n\n\n// --------------------------------- 写文件 -----------------------------// 加载文件操作模块var fs = require(&#x27;fs&#x27;);// 创建要写入的文件的字符串var msg = &#x27;你好，世界！你好 Node.js.&#x27;;// 执行文件写入操作fs.writeFile(&#x27;./data.txt&#x27;, msg, &#x27;utf8&#x27;, function (err) &#123;  console.log(&#x27;---&#x27; + err + &#x27;----&#x27;);  // /判断是否写入文件出错了  if (err) &#123;    console.log(&#x27;文件写入出错了，详细错误信息：&#x27; + err);    // 把错误继续向上抛出    throw err;  &#125; else &#123;    console.log(&#x27;文件写入成功！&#x27;);  &#125;&#125;);// --------------------------------- 读文件 -----------------------------// 加载文件操作模块var fs = require(&#x27;fs&#x27;);// 执行文件读取操作fs.readFile(&#x27;./data.txt&#x27;, &#x27;utf8&#x27;, function (err, data) &#123;  // 输出err  和 data  // console.log(&#x27;error: &#x27; + err);  // console.log(&#x27;data: &#x27; + data);  if (err) &#123;    console.log(&#x27;文件读取出错啦！详细信息: &#x27; + err);  &#125; else &#123;    console.log(&#x27;文件读取成功，以下是文件内容：&#x27;);    console.log(data);  &#125;&#125;);\n\n\n\n\n案例4：创建目录案例\n\n// 创建一个文件夹// 加载文件操作模块var fs = require(&#x27;fs&#x27;);// 创建一个目录fs.mkdir(&#x27;./test-mkdir&#x27;, function (err) &#123;  if (err) &#123;    console.log(&#x27;创建目录出错了，详细信息如下：&#x27;);    console.log(err);  &#125; else &#123;    console.log(&#x27;目录创建成功！&#x27;);  &#125;&#125;);// ----------------------------------------------------------// 加载文件操作模块var fs = require(&#x27;fs&#x27;);// 1. 创建 &#x27;01-教学资料&#x27; 目录fs.mkdir(&#x27;./01-教学资料&#x27;, function (err) &#123;  if (err) &#123;    throw err;  &#125;  // 1.1 创建 &#x27;01-笔记大纲&#x27; 目录  fs.mkdir(&#x27;./01-教学资料/01-笔记大纲&#x27;);  // 1.2 创建 &#x27;02-作业任务&#x27; 目录  fs.mkdir(&#x27;./01-教学资料/02-作业任务&#x27;);  // 1.3 创建 &#x27;03-素材资料&#x27; 目录  fs.mkdir(&#x27;./01-教学资料/03-素材资料&#x27;);  // 1.4 创建 &#x27;04-随堂笔记&#x27; 目录  fs.mkdir(&#x27;./01-教学资料/04-随堂笔记&#x27;);&#125;);// 2. 创建 &#x27;02-源代码&#x27; 目录fs.mkdir(&#x27;./02-源代码&#x27;, function (err) &#123;  if (err) &#123;    throw err;  &#125;  // 2.1 创建 &#x27;预习代码&#x27;目录  fs.mkdir(&#x27;./02-源代码/预习代码&#x27;);  // 2.2 创建 &#x27;课堂代码&#x27;目录  fs.mkdir(&#x27;./02-源代码/课堂代码&#x27;);&#125;);// 3. 创建 &#x27;03-视频&#x27; 目录fs.mkdir(&#x27;./03-视频&#x27;);// 4. 创建 &#x27;04-其他资料&#x27; 目录fs.mkdir(&#x27;./04-其他资料&#x27;);\n\n\n\n注意：\n异步操作无法通过 try-catch 来捕获异常，要通过判断 error 来判断是否出错。\n同步操作可以通过 try-catch 来捕获异常。\n不要使用 fs.exists(path, callback) 来判断文件是否存在，直接判断 error 即可\n文件操作时的路径问题\n\n\n在读写文件的时候 ‘.&#x2F;‘ 表示的是当前执行node命令的那个路径，不是被执行的js文件的路径\n__dirname, 表示的永远是”当前被执行的js的目录”\n__filename, 表示的是”被执行的js的文件名（含路径)”\n\n\nerror-first 介绍( 错误优先 )\n\n案例5：通过 node.js 编写 http 服务程序 - 极简版本步骤：\n\n加载http模块\n创建http服务\n为http服务对象添加 request 事件处理程序\n开启http服务监听，准备接收客户端请求\n\n注意：\n\n浏览器显示可能是乱码，所以可以通过 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain; charset=utf-8&#39;);设置浏览器显示时所使用的编码。\n\nChrome 浏览器默认无法手动设置编码，需要安装”Set Character Encoding”扩展。\n\n演示一下设置Content-Type=text/html 和 Content-Type=text/plain的区别。\n\n\n参考代码：\n// 1. 加载http模块var http = require(&#x27;http&#x27;);// 2. 创建http服务var server = http.createServer();// 3. 开始监听&#x27;request&#x27;事件server.on(&#x27;request&#x27;, function (req, res) &#123;  // body...  console.log(&#x27;有人请求了~~&#x27;);&#125;);// 4. 启动服务，开始监听server.listen(9000, function () &#123;  console.log(&#x27;服务已经启动，请访问： http://localhost:9000&#x27;);&#125;);\n\n\n\n\n案例6：通过 node.js 编写 http 服务程序 - 根据不同请求作出不同响应说明：\n根据不同请求，显示index页面、login页面、register页面、list页面。\n请求 &#x2F; 或 &#x2F;index\n请求 &#x2F;login\n请求 &#x2F;register\n请求 &#x2F;list\n\n参考代码// 加载http模块var http = require(&#x27;http&#x27;);// 创建http servervar server = http.createServer(function (req, res) &#123;  // body...  console.log(req.url);  if (req.url === &#x27;/&#x27; || req.url === &#x27;/index&#x27;) &#123;    // 表示请求网站首页    res.end(&#x27;这是 index.html&#x27;);  &#125; else if (req.url === &#x27;/login&#x27;) &#123;    // 表示请求登录页面    res.end(&#x27;这是 login.html&#x27;);  &#125; else if (req.url === &#x27;/register&#x27;) &#123;    // 表示请求注册页面    res.end(&#x27;这是 register.html&#x27;);      &#125; else if (req.url === &#x27;/list&#x27;) &#123;    // 表示请求列表页面    res.end(&#x27;这是 list.html&#x27;);      &#125; else &#123;    // 表示请求的页面不存在    res.writeHead(404, &#x27;Not Found&#x27;);    res.end(&#x27;Sorry, page not found.&#x27;);  &#125;&#125;);// 监听端口的网络请求server.listen(9000, function () &#123;  console.log(&#x27;http://localhost:9000&#x27;);&#125;);\n\n\n\n\n案例7：通过 node.js 编写 http 服务程序 - 通过读取静态 HTML 文件来响应用户请求步骤：\n\n创建index.html、login.html、register.html、list.html、404.html文件。 \n演示通过读取最简单的 HTML 文件来响应用户。\n演示通过读取”具有引入外部CSS样式表”的HTML文件来响应用户。\n演示通过读取”具有img标签”的HTML文件来响应用户。\n\n注意：\n\n1、注意在发送不同类型的文件时，要设置好对应的Content-Type\n\nContent-Type参考 OSChina\nContent-Type参考 MDN\n\n\n2、HTTP状态码参考\n\nw3org参考\nw3schools参考\n\n\n3、在html页面中写相对路径’.&#x2F;‘ 和 绝对路径 ‘&#x2F;‘的含义 。\n\n网页中的这个路径主要是告诉浏览器向哪个地址发起请求用的\n‘.&#x2F;‘ 表示本次请求从相对于当前页面的请求路径（即服务器返回当前页面时的请求路径）开始\n‘&#x2F;‘ 表示请求从根目录开始\n\n\n\n补充知识点：\n\npath 模块的 join() 方法\n\n参考代码：\n// 1. 加载 http 模块var http = require(&#x27;http&#x27;);// 加载文件操作模块var fs = require(&#x27;fs&#x27;);// 加载path模块，这个模块主要用来处理各种路径。var path = require(&#x27;path&#x27;);// 2. 创建http servervar server = http.createServer(function (req, res) &#123;  // 1. 获取用户请求的URL  var url = req.url.toLowerCase();  // 2. 根据用户的不同请求，做出不同响应  if (url === &#x27;/&#x27; || url === &#x27;/index&#x27;) &#123;    // 读取index.html文件，把该文件响应给用户    fs.readFile(path.join(__dirname, &#x27;index.html&#x27;), function (err, data) &#123;      if (err) &#123;        throw err;      &#125;      res.writeHead(200, &#x27;OK&#x27;, &#123;        &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;      &#125;);      // res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);      res.end(data);    &#125;);  &#125; else if (url === &#x27;/login&#x27;) &#123;    // 读取login.html文件，把该文件响应给用户    fs.readFile(path.join(__dirname, &#x27;login.html&#x27;), function (err, data) &#123;      if (err) &#123;        throw err;      &#125;      res.writeHead(200, &#x27;OK&#x27;, &#123;        &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;      &#125;);      // res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);      res.end(data);    &#125;);  &#125; else if (url === &#x27;/register&#x27;) &#123;    // 读取register.html文件，把该文件响应给用户    fs.readFile(path.join(__dirname, &#x27;register.html&#x27;), function (err, data) &#123;      if (err) &#123;        throw err;      &#125;      res.writeHead(200, &#x27;OK&#x27;, &#123;        &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;      &#125;);      // res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);      res.end(data);    &#125;);  &#125; else if (url === &#x27;/404&#x27;) &#123;    // 读取register.html文件，把该文件响应给用户    fs.readFile(path.join(__dirname, &#x27;404.html&#x27;), function (err, data) &#123;      if (err) &#123;        throw err;      &#125;      res.writeHead(200, &#x27;OK&#x27;, &#123;        &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;      &#125;);      // res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;);      res.end(data);    &#125;);  &#125;  &#125;);// 3. 启动服务server.listen(9090, function () &#123;  // body...  console.log(&#x27;please visit: http://localhost:9090&#x27;);&#125;);\n\n\n\n案例8：模拟 Apache 实现静态资源服务器步骤：\n\n单独创建一个目录来实现，比如：创建一个”07-Apache”的目录。\n在该目录下新建 public 目录，假设该目录为静态资源目录。\n根据用户请求的路径在 public 目录下寻找对应路径下的资源。\n如果找到了，那么将该资源返回给用户，如果没找到则返回404错误。\n通过 mime 模块设置不同类型资源的Content-Type\n实现完毕后把素材中的’An Ocean of Sky’ 和 ‘Hacker News’分别拷贝到静态资源目录下, 测试是否成功\n\n其他：\n\n介绍 NPM\n介绍 mime 第三方模块\nnpm install mime\n在代码中直接 var mime = require(&#39;mime&#39;)\n\n\n\n参考代码：\n// 1. 加载对应模块// 1.1 加载http模块var http = require(&#x27;http&#x27;);// 1.2 加载path模块，方便路径拼接var path = require(&#x27;path&#x27;);// 1.3 加载文件读取模块var fs = require(&#x27;fs&#x27;);// 1.4 加载判断文件MIME类型的模块var mime = require(&#x27;mime&#x27;);// 2. 创建http servervar server = http.createServer();// 3. 监听用户request事件server.on(&#x27;request&#x27;, function (req, res) &#123;  // 1. 获取用户的请求路径, 并转换为小写  var url = req.url.toLowerCase();  // 判断如果请求的路径是 &#x27;/&#x27; 那么等价于 &#x27;/index.html&#x27;  url = (url === &#x27;/&#x27;) ? &#x27;/index.html&#x27; : url;  // 2. 根据用户请求的url路径, 去public目录下查找对应的静态资源文件。找到后读取该文件，并将结果返回给用户  // 2.1 根据用户请求的url拼接本地资源文件的路径   var filePath = path.join(__dirname, &#x27;public&#x27;, url);  // 2.2 根据请求的文件路径设置Content-Type  res.setHeader(&#x27;Content-Type&#x27;, mime.lookup(url));  // 2.2 根据路径去读取对应的文件  // 【注意】读取文件前无需判断文件是否已经存在，而是在读取文件的回调函数中根据error的错误信息来判断读取文件是否成功以及发生的错误  fs.readFile(filePath, function (err, data) &#123;    // 判断是否有错误    if (err) &#123;      if (err.code === &#x27;ENOENT&#x27;) &#123; // 判断是否是请求的文件是否不存在        res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf8&#x27;);        res.statusCode = 404;        res.statusMessage = &#x27;Not Found&#x27;;        res.end(&#x27;&lt;h1&gt;请求的资源不存在！&lt;/h1&gt;&#x27;);      &#125; else if (err.code === &#x27;EACCES&#x27;) &#123; // 判断文件是否有访问权限        res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf8&#x27;);        res.statusCode = 403;        res.statusMessage = &#x27;Forbidden&#x27;;        res.end(&#x27;&lt;h1&gt;Permission denied！&lt;/h1&gt;&#x27;);      &#125; else &#123;        throw err;        &#125;    &#125; else &#123;            // 如果没有错误则将读取到的文件返回给用户      res.statusCode = 200;      res.statusMessage = &#x27;OK&#x27;;      res.end(data);    &#125;  &#125;)&#125;);// 4. 启动服务server.listen(9000, function () &#123;  // body...  console.log(&#x27;server is running, please visit: http://localhost:9000&#x27;);&#125;);\n\n\n\nCommon System Errors - 常见错误号\nEACCES (Permission denied)\n\nAn attempt was made to access a file in a way forbidden by its file access permissions.\n访问被拒绝\n\n\nEADDRINUSE (Address already in use)\n\nAn attempt to bind a server (net, http, or https) to a local address failed due to another server on the local system already occupying that address.\n地址正在被使用（比如：端口号备占用）\n\n\nEEXIST (File exists)\n\nAn existing file was the target of an operation that required that the target not exist.\n文件已经存在\n\n\nEISDIR (Is a directory)\n\nAn operation expected a file, but the given pathname was a directory.\n给定的路径是目录\n\n\nENOENT (No such file or directory)\n\nCommonly raised by fs operations to indicate that a component of the specified pathname does not exist – no entity (file or directory) could be found by the given path.\n文件 或 目录不存在\n\n\nENOTDIR (Not a directory)\n\nA component of the given pathname existed, but was not a directory as expected. Commonly raised by fs.readdir.\n给定的路径不是目录\n\n\n\n同步文件操作 和 异步文件操作\nfs.readFile(file[, options], callback)\nfs.readFileSync(file[, options])\n\n通过设置 http 响应报文头实现弹框下载功能\n设置 Content-Type: application/octet-stream\n设置 Content-Disposition: attachment; filename=demo.txt\n\n"},{"title":"Web开发本质","url":"/2023/10/31/01-Web%E5%BC%80%E5%8F%91%E6%9C%AC%E8%B4%A8/","content":"Web开发本质牢记以下三点\n请求，客户端发起请求。\n处理，服务器处理请求。\n响应，服务器将处理结果发送给客户端\n\n对比一个单机版计算器和Web版计算器客户端处理响应\n服务器响应完毕后，客户端继续处理：\n浏览器：解析服务器返回的数据\niOS、Android 客户端，解析服务器返回的数据，并且通过iOS或Android的UI技术实现界面的展示功能\n\n\n\n关于 C&#x2F;S（Client&#x2F;Server） 和 B&#x2F;S（Browser&#x2F;Server）C&#x2F;S: 客户端服务器\nB&#x2F;S: 浏览器服务器\n\n"},{"title":"跳动爱心","url":"/2023/10/31/03-%E7%88%B1%E5%BF%83%E4%BB%A3%E7%A0%81/","content":"&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;跳动爱心&lt;/title&gt;    &lt;style&gt;      * &#123;        padding: 0;        margin: 0;      &#125;      body &#123;        background-color: pink;      &#125;      #frame &#123;        position: relative;        width: 400px;        height: 300px;        margin: 250px auto;      &#125;      .left,      .right &#123;        top: 0;        width: 200px;        height: 200px;        border-radius: 50%;      &#125;      .left &#123;        left: 35px;      &#125;      .right &#123;        right: 35px;        z-index: -1;      &#125;      .bottom &#123;        bottom: 36px;        left: 100px;        width: 200px;        height: 200px;        transform: rotate(45deg);        z-index: -1;      &#125;      .heart &#123;        position: absolute;        box-shadow: 0 0 40px #d5093c;        animation: beat 0.8s ease infinite normal;        background: linear-gradient(-90deg, #f50a45 0%, #d5093c 40%);      &#125;      @keyframes beat &#123;        0% &#123;          transform: scale(1) rotate(225deg);          box-shadow: 0 0 40px #d5093c;        &#125;        50% &#123;          transform: scale(1.1) rotate(225deg);          box-shadow: 0 0 70px #d5093c;        &#125;        100% &#123;          transform: scale(1) rotate(225deg);          box-shadow: 0 0 40px #d5093c;        &#125;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;frame&quot;&gt;      &lt;div class=&quot;heart left&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;heart right&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;heart bottom&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;"}]