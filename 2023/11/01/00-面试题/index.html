<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Zhao zhao">
    
    <title>
        
            面试题 |
        
        小赵博客
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="https://pic1.zhimg.com/80/v2-c048e14cd4ca3faf0bacaa08623097cc_720w.webp">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066cc","favicon":"https://pic1.zhimg.com/80/v2-c048e14cd4ca3faf0bacaa08623097cc_720w.webp","font_size":"15px","font_family":"STKaiti","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"header_transparent":true,"hitokoto":true},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":true,"preload":false},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":false,"custom_label_list":["炼气","筑基","结丹","元婴","化神"]},"datetime_format":"YYYY-MM-DD","word_count":{"enable":true,"wordcount":false,"min2read":false},"img_align":"center","copyright_info":false},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"version":"3.8.6"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original article title","author":"Original article author","link":"Original article link"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container border-box">

    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
            <a class="site-name border-box" href="/">
               小赵博客
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">

                

                    <div class="fade-in-down-animation">
    <div class="post-page-container border-box">

        <div class="article-content-container border-box">

            

            <div class="article-content-bottom border-box">
                
                    <div class="article-title">
                        面试题
                    </div>
                

                
                    <div class="article-header border-box">
                        
                        <div class="info-box">
                            <div class="author">
                                <span class="name">Zhao zhao</span>
                                
                                    <span class="author-label">炼气</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="article-meta-info-container border-box post">
    <div class="article-meta-info border-box">
        


        
            <span class="meta-info-item article-create-date">
                <i class="icon fa-solid fa-calendar-check"></i>&nbsp;
                <span class="pc">2023-11-01</span>
                <span class="mobile">2023-11-01 16:36</span>
            </span>

            <span class="meta-info-item article-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="pc" data-updated="Wed Nov 01 2023 16:38:50 GMT+0800">2023-11-01</span>
            </span>
        

        

        

        
        
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="article-content keep-markdown-body">
                    

                    <h4 id="js面试题"><a href="#js面试题" class="headerlink" title="js面试题"></a>js面试题</h4><h1 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h1><pre><code>基本数据类型：string、number、布尔、undefined、null BigInt 更精准的数  Symbol 处理对象重复的key
引用数据类型: 栈中存的是引用地址，值存在堆内存 object、array、function、RegExp、Date、Math  
堆是先进先出 - 栈是先进后出
</code></pre>
<h1 id="2-转换方法"><a href="#2-转换方法" class="headerlink" title="2.转换方法"></a>2.转换方法</h1><pre><code>Number()
强制转换为数字 其他方法还有：在前加+ 、减-、乘*、除/
规则：能转换成数字的优先转成数字，实在转不出来就转成NaN
    Boolean()  转换布尔 显示转换 隐式转换  转换的规则：非空非0即为真
    toString() 转换字符串 并不是用来转成字符串的，而是用来检测数据类型的 null和undefined不能用toString()转
    isNaN() 判断是不是非数字 判断规则：判断之前先用Number()方法做隐式转换
    判断规则：null只和undefined和它本身相等 其余的null、undefined不和任何值相等 判断之前有一个Number()方法的隐式转换
</code></pre>
<h1 id="3-对象解构赋值和数组解构赋值"><a href="#3-对象解构赋值和数组解构赋值" class="headerlink" title="3.对象解构赋值和数组解构赋值"></a>3.对象解构赋值和数组解构赋值</h1><pre><code>对象展开运算符
let obj = &#123;
hello: &#39;hello&#39;,
world: &#39;world&#39;,
name: &#39;Tim&#39;,
age: 18
&#125;
let &#123;hello, world, ...hi&#125; = obj;
数组使用扩展运算符解构
function f () &#123;
return [&#39;hello&#39;, &#39;world&#39;, &#39;my&#39;, &#39;name&#39;, &#39;is Lilei&#39;];
&#125;
let [hello, world, ...who] = f()
</code></pre>
<h1 id="4-js-获取-dom-的方法"><a href="#4-js-获取-dom-的方法" class="headerlink" title="4.js 获取 dom 的方法"></a>4.js 获取 dom 的方法</h1><pre><code>通过 ID 获取（getElementById）
通过 name 属性（getElementsByName）
通过标签名（getElementsByTagName）
通过类名（getElementsByClassName）
获取 html 的方法（document.documentElement）
获取 body 的方法（document.body）
通过 css 选择器获取一个元素（document.querySelector）
通过选择器获取一组元素（document.querySelectorAll）
</code></pre>
<h1 id="5-获取和设置元素属性的方法"><a href="#5-获取和设置元素属性的方法" class="headerlink" title="5.获取和设置元素属性的方法"></a>5.获取和设置元素属性的方法</h1><pre><code>元素.setAttribute(&#39;属性名&#39;,属性值) 设置元素的行间属性，如果原来有这个行间属性会覆盖原来的行间属性
元素.getAttribute(&#39;属性名&#39;) 获取元素的行间属性对应的属性值，不能获取 css 样式对应的属性值 如果获取的属性不存在返回 null
getComputedStyle 获取经过浏览器计算后的属性 获取的结果是带单位的字符串
</code></pre>
<h1 id="6-js-dom-元素方法"><a href="#6-js-dom-元素方法" class="headerlink" title="6.js dom 元素方法"></a>6.js dom 元素方法</h1><pre><code>1. 如何在 dom 元素前面添加元素（内部添加）
dom.insertBefore(newDom,dom.firstChild)
2. 如何在 dom 元素前面添加元素（外部添加）
dom.parentNode.inserBefore(newDom,dom)
3. 如何在 dom 元素后面添加元素(外部添加)
dom.parentNode.insertBefore(newDom,dom.nextSibling)
4. dom.appendChild(dom 元素)，元素尾部添加新元素（内部添加）
js 有哪些动态添加 dom 元素的方法？
-  parent.appendChild(newDom,existDom) 在 existDom 的前面添加新元素，parent 为 existDom 的父元素
js 有哪些删除元素的方法
1. dom.remove();自身调用 remove 删除
2. parent.removeChild(child) 父元素删除子元素
</code></pre>
<h1 id="7-js-如何判断一个变量时-null-undefined"><a href="#7-js-如何判断一个变量时-null-undefined" class="headerlink" title="7.js 如何判断一个变量时 null&#x2F;undefined"></a>7.js 如何判断一个变量时 null&#x2F;undefined</h1><pre><code>用==null 来判断是否为 undefined 或 null 值
因为!null 为真，所以也可以简单的把判断语句改为！null 写法来同时判断 undefined 或 null 值
</code></pre>
<h1 id="8-js-判断是否为对象"><a href="#8-js-判断是否为对象" class="headerlink" title="8.js 判断是否为对象"></a>8.js 判断是否为对象</h1><pre><code>typeof:  主要用来检查基本数据类型
instanceof: 用于检测构造函数中的原型(prototype)属性是否出现在某个实例对象的原型链上
constructor: 用于检测实例对象是否是由某个构造函数实例化出来的
object.prototype.toString().call():检测对象的时候不用加call，别的数据类型必须用call，否则的话就变成了转成字符串的方法了
</code></pre>
<h1 id="9-new-关键字做了哪些事情？"><a href="#9-new-关键字做了哪些事情？" class="headerlink" title="9.new 关键字做了哪些事情？"></a>9.new 关键字做了哪些事情？</h1><pre><code>1.在堆内存中申请一块空间，创建一个新对象&#123;&#125;
2.新对象的__proto__指向构造函数中的原型对象prototype
3.确认this指向让上下文中this指向这个新对象
4.执行构造函数中的代码 初始化新对象
5.返回新对象 返回的是新对象的地址值 即便没有return 构造函数也会默认返回this
</code></pre>
<h1 id="10-字符串反转方式"><a href="#10-字符串反转方式" class="headerlink" title="10.字符串反转方式"></a>10.字符串反转方式</h1><pre><code>let newStr = str.split(&quot;&quot;).reverse().join(&quot;&quot;);
</code></pre>
<h1 id="11-jquery-的“-”有什么作用-可以把-换成其他的吗？"><a href="#11-jquery-的“-”有什么作用-可以把-换成其他的吗？" class="headerlink" title="11.jquery 的“$”有什么作用?可以把$换成其他的吗？"></a>11.jquery 的“$”有什么作用?可以把$换成其他的吗？</h1><pre><code>$是JQuery常用的一个回传函数，定义为 “选取”，英文是 selector 的缩写
</code></pre>
<p>$其实是 jQuery 的别称，而 jQuery 就是 jQuery 库提供的一个函数。<br>    该函数可以根据 () 里的参数进行查找和选择 html 文档中的元素，()内不仅可以是 ID，还可以是各类选择器<br>    可以替换，var jquery$ &#x3D; jQuery.noConflict();</p>
<h1 id="12-tcp-和-udp-区别"><a href="#12-tcp-和-udp-区别" class="headerlink" title="12.tcp 和 udp 区别"></a>12.tcp 和 udp 区别</h1><pre><code>他俩是什么？
    是运输层的两种协议：
        运输层就是负责向两台主机之间进行通信提供通用的数据传输服务，应用进程利用该服务传送应用层报文
TCP 是面向连接的，UDP 是无连接的
TCP 是可靠的，UDP 是不可靠的
TCP 是面向字节流的，UDP 是面向数据报文的
TCP 只支持点对点通信，UDP 支持一对一，一对多，多对多
TCP 报文首部 20 个字节，UDP 首部 8 个字节
TCP 有拥塞控制机制，UDP 没有
TCP 协议下双方发送接受缓冲区都有，UDP 并无实际意义上的发送缓冲区，但是存在接受缓冲区
</code></pre>
<h1 id="13-ajax请求的五个步骤，"><a href="#13-ajax请求的五个步骤，" class="headerlink" title="13.ajax请求的五个步骤，"></a>13.ajax请求的五个步骤，</h1><p>创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。</p>
<h1 id="14-浏览器渲染过程"><a href="#14-浏览器渲染过程" class="headerlink" title="14.浏览器渲染过程"></a>14.浏览器渲染过程</h1><pre><code>将获取的 html 解析成 dom 树
处理 css，构成层叠样式表模型 CSSOM（是对CSS样式表的对象化表示，同时还提供了相关API用来操作CSS样式）
将 dom 树和 CSSOM 合并为渲染树
根据 CSSOM 将渲染树的节点布局计算
将渲染树节点样式绘制到页面上
</code></pre>
<h1 id="15-浅拷贝与深拷贝"><a href="#15-浅拷贝与深拷贝" class="headerlink" title="15.浅拷贝与深拷贝"></a>15.浅拷贝与深拷贝</h1><pre><code>浅拷贝： 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用 
方法：- Object.assign(目标对象，源对象)
    - var obj1=&#123;&#125;
        for(var key in obj)&#123;
        obj1[key]=obj[key]
        &#125;
    - obj1=&#123;...obj&#125;;
    - concat
深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”
方式：- 使用jq中的$.extend
    - 用JSON.parse(JSON.stringify(你要复制的对象))
    - 递归
</code></pre>
<h1 id="16-统计字符串中每个字母出现的次数"><a href="#16-统计字符串中每个字母出现的次数" class="headerlink" title="16. 统计字符串中每个字母出现的次数"></a>16. 统计字符串中每个字母出现的次数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;str.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> key =str[i]</span><br><span class="line">    <span class="keyword">if</span>(obj[key])&#123;</span><br><span class="line">        obj[key]++</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        obj[key]=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key i obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key+<span class="string">&#x27;出现了&#x27;</span>+obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="17-什么是-IIFE"><a href="#17-什么是-IIFE" class="headerlink" title="17. 什么是 IIFE"></a>17. 什么是 IIFE</h1><pre><code>立即执行函数表达式：IIFE（Immediately-invoked function expression）
总结 IFEE 的优点： 1.创建块级（私有）作用域，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突；
2.IIFE 中定义的任何变量和函数，都会在执行结束时被销毁。这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了；
</code></pre>
<h1 id="18-如何改变this指向"><a href="#18-如何改变this指向" class="headerlink" title="18.如何改变this指向"></a>18.如何改变this指向</h1><pre><code>是函数的方法
call 传参只能传值 可以直接调用
apply 传参只能传数组 可以直接调用 应用场景：找出数组的最大值/最小值
bind 只能传值 默认不能直接调用 应用场景：事件或者计时器里边修改this指向 
</code></pre>
<h1 id="19-如何阻止事件冒泡和默认事件"><a href="#19-如何阻止事件冒泡和默认事件" class="headerlink" title="19.如何阻止事件冒泡和默认事件"></a>19.如何阻止事件冒泡和默认事件</h1><pre><code>event.stopPropagation()：阻止事件的冒泡方法
event.preventDefault()：阻止默认事件的方法
return false：就等于同时调用了 event.stopPropagation()和 event.preventDefault()
</code></pre>
<h1 id="20-JavaScript-三大对象：本地对象、内置对象、宿主对象"><a href="#20-JavaScript-三大对象：本地对象、内置对象、宿主对象" class="headerlink" title="20.JavaScript 三大对象：本地对象、内置对象、宿主对象"></a>20.JavaScript 三大对象：本地对象、内置对象、宿主对象</h1><pre><code>a.本地对象
与宿主无关，无论在浏览器还是服务器中都有的对象，就是 ECMAScript 标准中定义的类(构造函数)
在使用过程中需要我们手动 new 创建
例如：Boolean、Number、String、Array、Function、Object、Date、RegExp 等
b.内置对象
与宿主无关，无论在浏览器还是服务器中都有的对象
ECMAScript 已经帮我们创建好的对象
在使用过程中无需我们动手 new 创建
例如：Global、Math、JSON
c.宿主对象
什么是宿主？
宿主就是指 JavaScript 运行环境，js 可以在浏览器中运行，也可以在服务器上运行(nodejs)
对于嵌入到网页中的 js 来说，其宿主对象就是浏览器，所以宿主对象就是浏览器提供的对象
包含：Window 和 Docuument 等
所有的 DOM 和 BOM 对象都属于宿主对象
</code></pre>
<h1 id="21-数组扁平化-数组拉平"><a href="#21-数组扁平化-数组拉平" class="headerlink" title="21.数组扁平化&#x2F;数组拉平"></a>21.数组扁平化&#x2F;数组拉平</h1><pre><code>- 用 ECMAscript 2019 中的 arr.flat(Infinity) 方法
- 利用 arr.toString(），将数组转换为字符串
再利用 str.split（‘ ，’），将字符串转换为新的数组
map遍历，parseInt（）每一项转数组
- 使用 ES6 新增的扩展运算符
- 递归  
</code></pre>
<h1 id="22-map-filter-for-in-的区别"><a href="#22-map-filter-for-in-的区别" class="headerlink" title="22.map,filter,for in 的区别"></a>22.map,filter,for in 的区别</h1><pre><code>map 则可以改变当前循环的值，返回一个新的被改变过值之后的数组（map 需 return）
filter 函数可以看成是一个过滤函数，返回符合条件的元素的数组
for…in 循环数组索引、对象的属性，但使用 for…in 原型链上的所有属性都将被访问，用 hasOwnProperty() 方法解决。map 方法有返回值，可以 return 出来
</code></pre>
<h1 id="23-js-中实例方法和原型方法的区别"><a href="#23-js-中实例方法和原型方法的区别" class="headerlink" title="23.js 中实例方法和原型方法的区别"></a>23.js 中实例方法和原型方法的区别</h1><pre><code>实例方法就是只有实例可以调用，静态方法只有构造函数可以调用，原型方法是实例和构造函数都可以调用，是共享的方法
像Promise.all和Promise.race这些就是静态方法，Promise.prototype.then这些就是原型方法，new 出来的实例可以调用
</code></pre>
<h1 id="24-节流和防抖的区别"><a href="#24-节流和防抖的区别" class="headerlink" title="24.节流和防抖的区别"></a>24.节流和防抖的区别</h1><pre><code>防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于设置的时间，防抖的情况下只会调用一次，而节流的情况会每隔一定时间调用一次函数。
</code></pre>
<h1 id="25-浏览器内核"><a href="#25-浏览器内核" class="headerlink" title="25.浏览器内核"></a>25.浏览器内核</h1><pre><code>  浏览器内核又可以分成两部分：渲染引擎和JS引擎
  渲染引擎：负责获取网页的内容并显示，不同的浏览器内核对网页的解析渲染也不同
  JS引擎：负责解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果
  常用内核(内核种类很多)
      常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit
</code></pre>
<h1 id="26-实现浏览器内多个标签页面之间通信"><a href="#26-实现浏览器内多个标签页面之间通信" class="headerlink" title="26.实现浏览器内多个标签页面之间通信"></a>26.实现浏览器内多个标签页面之间通信</h1><pre><code>一、cookie + setInterval 方式
二、localStorage 方式
三、webSocket 方式
</code></pre>
<h1 id="27-jQuery-对象与-DOM-对象的相互转化"><a href="#27-jQuery-对象与-DOM-对象的相互转化" class="headerlink" title="27.jQuery 对象与 DOM 对象的相互转化"></a>27.jQuery 对象与 DOM 对象的相互转化</h1><p>jq转dom<br>    - 利用数组下标的方式读取 jQuery 中的 DOM 对象 var div &#x3D; $div[0]<br>    - jQuery对象自身提供一个.get()方法允许我们直接访问jQuery对象中相关的DOM节点，get方法中提供了一个元素的索引var div &#x3D; $div.get(0)<br>dom转jq<br>    对象加工成一个 jQuery 对象。$(参数)是一个对功能大方法，通过传递不同的参数而产生不同的作用，<br>    var div &#x3D; $(div)</p>
<h1 id="28-jQuery-获取的-dom-对象和原生的-dom-对象有何区别？"><a href="#28-jQuery-获取的-dom-对象和原生的-dom-对象有何区别？" class="headerlink" title="28.jQuery 获取的 dom 对象和原生的 dom 对象有何区别？"></a>28.jQuery 获取的 dom 对象和原生的 dom 对象有何区别？</h1><pre><code>js 原生获取的 dom 是一个对象，jQuery 对象就是一个数组对象，其实就是选择出来的元素的数组集合，所以说他们两者是不同的对象类型不等价。
</code></pre>
<h1 id="29-Jq-如何扩展自定义方法"><a href="#29-Jq-如何扩展自定义方法" class="headerlink" title="29.Jq 如何扩展自定义方法"></a>29.Jq 如何扩展自定义方法</h1><pre><code>\$.extend(&#123;
　　 a:function ()&#123;
　　　　 alert(&#39;I&#39; m lc&#39;);
　　&#125;
&#125;)
</code></pre>
<h1 id="30-jq-给所有元素加虚线"><a href="#30-jq-给所有元素加虚线" class="headerlink" title="30.jq 给所有元素加虚线"></a>30.jq 给所有元素加虚线</h1><pre><code>\$(&quot;\*&quot;).css(&quot;border:2px dotted/dashed #000;&quot;)
</code></pre>
<h1 id="31-关于-jquery-的-load-方法"><a href="#31-关于-jquery-的-load-方法" class="headerlink" title="31.关于 jquery 的 load()方法"></a>31.关于 jquery 的 load()方法</h1><pre><code>jquery load 方法是对 jQuery.ajax()进行封装以方便我们使用的一个方法，当我们需要处理较为复杂的逻辑时候，还是需要用到 jQuery.ajax()这个比较全面的方法的。
load()主要用来加载 header、footer、siderbar、tip(提示框/输入框)等多个公共组件，以及简单的调用动态接口。
完整语法格式：load( url, [data], [callback] )
参数:
url 是指要导入文件的地址。
data： 可选参数；因为 load 不仅仅可以导入静态的 html 文件，还可以导入动态脚本，例如 PHP 文件，所以要导入的是动态文件时，
我们可以把要传递的参数放在这里。
callback：可选参数；是指调用 load 方法并得到服务器响应后，再执行的另外一个函数；回调参数：response, status, xhr
</code></pre>
<h2 id="ajax-方法"><a href="#ajax-方法" class="headerlink" title="$.ajax 方法"></a>$.ajax 方法</h2><p>url 表示请求的地址<br>type 表示请求的类型 GET 或 POST 请求<br>data 表示发送给服务器的数据格式有两种： 一：name&#x3D;value&amp;name&#x3D;value 二：{key:value}<br>success 请求成功，响应的回调函数</p>
<h1 id="32-document-ready-和-window-onload-的区别"><a href="#32-document-ready-和-window-onload-的区别" class="headerlink" title="32.document.ready 和 window.onload 的区别"></a>32.document.ready 和 window.onload 的区别</h1><pre><code>页面加载完成有两种事件，一是 ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是 onload，指示页面包含图片等文件在内的所有元素都加载完成。
ready先加载，onload页面加载完之后加载
</code></pre>
<h1 id="33-瀑布流实现的原理"><a href="#33-瀑布流实现的原理" class="headerlink" title="33.瀑布流实现的原理"></a>33.瀑布流实现的原理</h1><pre><code>瀑布流布局要求要进行布置的元素等宽，然后计算元素的宽度与浏览器宽度之比，得到需要布置的列数。
创建一个数组，长度为列数，里面的值为已布置元素的总高度（最开始为 0）
然后将未布置的元素依次布置到高度最小的那一列，就得到了瀑布流布局。
</code></pre>
<h1 id="34-lazyload-的实现原理"><a href="#34-lazyload-的实现原理" class="headerlink" title="34.lazyload 的实现原理"></a>34.lazyload 的实现原理</h1><pre><code>图片可视 iscando 为 false，获取页面滚动高度，再判断图片是否在用户可视范围之内，如果在的话，将图片的 iscando 设为 true，声明一个 src 地址合集，当可视范围为 true 时，将 src 赋值给图片的 src 属性
加载条件
img.offsetTop &lt; window.innerHeight + document.body.scrollTop;
var imgs = document.querySelectorAll(&#39;img&#39;);
window.onscroll = function()&#123;
var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
var winTop = window.innerHeight;
for(var i=0;i &lt; imgs.length;i++)&#123;
if(imgs[i].offsetTop &lt; scrollTop + winTop )&#123;
imgs[i].src = imgs[i].getAttribute(&#39;data-src&#39;);
&#125;
&#125;
&#125;
实现性能提高需要将节流和懒加载一起使用
</code></pre>
<h1 id="35-Array-与-ArrayBuffer-的区别"><a href="#35-Array-与-ArrayBuffer-的区别" class="headerlink" title="35.Array 与 ArrayBuffer 的区别"></a>35.Array 与 ArrayBuffer 的区别</h1><pre><code>ArrayBuffer 只能定义长度，无法直接读取它的内容
每个 ArrayBuffer 对象表示的只是内存中指定的字节数;
但不会指定这些字节用于保存什么类型的数据；
通过 ArrayBuffer 能做的，就是为了将来使用而分配一定数量的字节.
</code></pre>
<h1 id="36-js-在浏览器兼容有那些问题"><a href="#36-js-在浏览器兼容有那些问题" class="headerlink" title="36.js 在浏览器兼容有那些问题"></a>36.js 在浏览器兼容有那些问题</h1><pre><code>HTML 对象获取问题
FireFox：document.getElementById(“idName”);
ie:document.idname 或者 document.getElementById(“idName”).
自定义属性问题
IE 下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性；Firefox 下，只能使用 getAttribute() 获取自定义属性。
解决方法：统一通过 getAttribute() 获取自定义属性。
</code></pre>
<h1 id="37-document-write-和-innerHTML-的区别"><a href="#37-document-write-和-innerHTML-的区别" class="headerlink" title="37.document.write()和 innerHTML 的区别"></a>37.document.write()和 innerHTML 的区别</h1><pre><code>document.write 是重写整个 document, 写入内容是字符串的 html，会导致页面全部重绘
innerHTML 是 HTMLElement 的属性，是一个元素的内部 html 内容，不会导致页面全部重绘
</code></pre>
<h1 id="38-JavaScript-中的作用域、作用域链"><a href="#38-JavaScript-中的作用域、作用域链" class="headerlink" title="38.JavaScript 中的作用域、作用域链"></a>38.JavaScript 中的作用域、作用域链</h1><pre><code>作用域的本质是一个保存变量的对象，作用域避免了不同范围内的数据的相互干扰。
变量的作用域无非就是两种：全局变量和局部变量。
全局作用域：
最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的：
局部作用域：
和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部
作用域链是由多级作用域串联形成的链式结构
根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问。将会按照作用域链一级级向上寻找搜索
延长作用域链就是在作用域链的前端增加一个变量对象。“with语句”
</code></pre>
<h1 id="39-为什么异步加载-js-，加载方式"><a href="#39-为什么异步加载-js-，加载方式" class="headerlink" title="39.为什么异步加载 js ，加载方式"></a>39.为什么异步加载 js ，加载方式</h1><pre><code>异步加载是立即下载 js 脚本的同时又不妨碍页面中的其他操作。
defer：规定是否对脚本执行进行延迟，但却是并行下载，要等到 DOM 文档全部加载解析好了，才会被执行。只有 IE 能用，也可以将代码写到内部
&lt;script type=&quot;text/javascript&quot; src=&quot;demo.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;

async：异步加载，加载好了就执行，不管页面是否解析好。async 只能加载外部脚本，不能把 js 写在 script 标签里(IE9 以上都能执行，比较普遍)
动态创建 script 标签插入到 dom 元素中
</code></pre>
<h1 id="40-js-面向对象的继承方法"><a href="#40-js-面向对象的继承方法" class="headerlink" title="40.js 面向对象的继承方法"></a>40.js 面向对象的继承方法</h1><pre><code>1、通过改变原型的指向实现继承
2、借用父级构造函数实例继承(通过call修改this指向)
3、组合继承
原型继承，混合继承
</code></pre>
<h1 id="41-重绘和重排"><a href="#41-重绘和重排" class="headerlink" title="41.重绘和重排"></a>41.重绘和重排</h1><pre><code>重绘是一个元素外观的改变导致的浏览器行为（例如改变 visibility，outline，background 等属性），浏览器会根据元素新的属性呈现新的外观；
重排是 DOM 元素被 js 触发某种变化，渲染树需要重新计算。浏览器对 DOM 树进行重新排列；这便是重排。排列完成之后重新绘制元素则是重绘。
</code></pre>
<h1 id="42-js-去除空格"><a href="#42-js-去除空格" class="headerlink" title="42.js 去除空格"></a>42.js 去除空格</h1><pre><code>str.replace(/\s+/g,&quot;&quot;);
</code></pre>
<h1 id="43-使用-es5-语法，如何将一个类似数组的对象转换为数组？（比如-document-getElementsByTagName-…-的返回值）"><a href="#43-使用-es5-语法，如何将一个类似数组的对象转换为数组？（比如-document-getElementsByTagName-…-的返回值）" class="headerlink" title="43.使用 es5 语法，如何将一个类似数组的对象转换为数组？（比如 document.getElementsByTagName(…)的返回值）"></a>43.使用 es5 语法，如何将一个类似数组的对象转换为数组？（比如 document.getElementsByTagName(…)的返回值）</h1><pre><code>Array.prototype.slice.call(document.getElementsByTagName(...))
</code></pre>
<h1 id="44-js-如何判读一个对象是否为空对象"><a href="#44-js-如何判读一个对象是否为空对象" class="headerlink" title="44.js 如何判读一个对象是否为空对象"></a>44.js 如何判读一个对象是否为空对象</h1><pre><code>for in 遍历这个对象，如果有值的话，就不是空，否则就是空
  var obj = &#123;&#125;;
  var b = function() &#123;
  for(var key in obj) &#123;
  return false;
  &#125;
  return true;
  &#125;
  将对象转化为 json 字符串，再判断该字符串是否为&quot;&#123;&#125;&quot;
  var data = &#123;&#125;;
  var b = (JSON.stringify(data) == &quot;&#123;&#125;&quot;);
  alert(b);
</code></pre>
<h1 id="45-dom-元素上的-property-和-attribute-的区别"><a href="#45-dom-元素上的-property-和-attribute-的区别" class="headerlink" title="45.dom 元素上的 property 和 attribute 的区别"></a>45.dom 元素上的 property 和 attribute 的区别</h1><pre><code>  对属性 Property 可以赋任何类型的值，而对特性 Attribute 只能赋值字符串！
  对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的
  但是对于自定义的属性来说，他们是不同步的.(自定义属性不会自动添加到 property)
  1.property 能够从 attribute 中得到同步；
  2.attribute 不会同步 property 上的值；
</code></pre>
<h1 id="46-js-控制循环的方法"><a href="#46-js-控制循环的方法" class="headerlink" title="46.js 控制循环的方法"></a>46.js 控制循环的方法</h1><pre><code>  break
  终止循环
  跳出本层循环，继续执行循环后面的语句。
  如果循环有多层，则 break 只能跳出一层
  continue
  跳过本次循环剩余的代码，继续执行下一次循环。
</code></pre>
<h1 id="47-斐波那契"><a href="#47-斐波那契" class="headerlink" title="47.斐波那契"></a>47.斐波那契</h1><pre><code>  function Fibonacci(n)&#123;
  if(n == 1 || n == 2)&#123;
  return 1;
  &#125;
  else&#123;
  return Fibonacci(n - 1) + Fibonacci(n - 2);
  &#125;
  &#125;
</code></pre>
<h1 id="48-事件冒泡"><a href="#48-事件冒泡" class="headerlink" title="48.事件冒泡"></a>48.事件冒泡</h1><pre><code>  事件冒泡：当某个元素的某类型事件被触发时（如 onclick），它父级的同类型事件也会被触发，它的父级的父级同类型事件也会被触发，以此类推，一直触发到根元素。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。
  事件冒泡有下到上，事件捕获有上到下
</code></pre>
<h1 id="49-JavaScript-的同源策略"><a href="#49-JavaScript-的同源策略" class="headerlink" title="49.JavaScript 的同源策略"></a>49.JavaScript 的同源策略</h1><pre><code>  同源：协议、域名、端口全部相同才是同源，考虑到安全性，不同源之间不能够进行数据通信
</code></pre>
<h1 id="50-url组成"><a href="#50-url组成" class="headerlink" title="50.url组成"></a>50.url组成</h1><pre><code>http:/https: 协议
www.baidu.com 域名
:8080 端口
/sf/vsearch 路径
?wd=百度热搜 查询(可有可无)
#a=1&amp;b=2 哈希值(可有可无)
</code></pre>
<h1 id="51-for-in-和-for-of-循环的区别"><a href="#51-for-in-和-for-of-循环的区别" class="headerlink" title="51.for in 和 for of 循环的区别 ?"></a>51.for in 和 for of 循环的区别 ?</h1><pre><code>`for in` 用于遍历对象的键(`key`)，`for in`会遍历所有自身的和原型链上的可枚举属性。如果是数组，
</code></pre>
<p>for in会将数组的索引(index)当做对象的key来遍历，其他的object也是一样的。<br>    <code>for of</code>是<code>es6</code>引入的语法，用于遍历 所有迭代器iterator，其中包括<br><code>HTMLCollection</code>,<code>NodeList</code>,<code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>TypedArray</code>，<code>arguments</code>等<br>对象的值(<code>item</code>)</p>
<h1 id="52-url请求过程"><a href="#52-url请求过程" class="headerlink" title="52.url请求过程"></a>52.url请求过程</h1><pre><code>    DNS 解析:将域名地址解析成 IP 地址
    TCP 连接：TCP 三次握手
    处理请求：发送请求
    接收响应：响应报文
    渲染页面：浏
    断开连接：四次挥手
</code></pre>
<h1 id="53-10-50的随机数"><a href="#53-10-50的随机数" class="headerlink" title="53.10-50的随机数"></a>53.10-50的随机数</h1><pre><code>- Math.floor(Math.random()*39)+10
- Math.ceil(Math.random()*40)+10
</code></pre>
<h1 id="54-获取时间"><a href="#54-获取时间" class="headerlink" title="54.获取时间"></a>54.获取时间</h1><pre><code>var date = new Date();
    var year = date.getFullYear();    //  返回的是年份
    var month = date.getMonth() + 1;  //  返回的月份上个月的月份，记得+1才是当月
    var dates = date.getDate();       //  返回的是几号
    var day = date.getDay();          //  周一返回的是1，周六是6，但是周日是0
</code></pre>
<h1 id="55-性能优化"><a href="#55-性能优化" class="headerlink" title="55.性能优化"></a>55.性能优化</h1><pre><code>减少请求数量、使用缓存、减少资源大小、精灵图
</code></pre>
<h1 id="56-eval-的作用"><a href="#56-eval-的作用" class="headerlink" title="56.eval()的作用"></a>56.eval()的作用</h1><p>eval()可以接受一个字符串str作为参数，并把这个参数作为脚本代码来执行。<br>    eval(string) 函数计算 JavaScript 字符串，并把它作为脚本代码来执行<br>    如果参数是一个表达式，eval() 函数将执行表达式；<br>    如果参数是Javascript语句，eval()将执行 Javascript 语句；<br>    如果执行结果是一个值就返回，不是就返回undefined，如果参数不是一个字符串，则直接返回该参数。<br>    特殊：eval(“{b:2}”) &#x2F;&#x2F; 声明一个对象<br>    eval(“（{b:2}）”) &#x2F;&#x2F; 返回对象{b:2}</p>
<h2 id="Function和eval有什么区别？"><a href="#Function和eval有什么区别？" class="headerlink" title="Function和eval有什么区别？"></a>Function和eval有什么区别？</h2><p>共同点：都可以将字符串转化为js代码<br>不同点：Function创建出来的函数并不会直接调用，只有当手动去调用创建出来的函数的时候才调用，eval把字符串转化为代码后，直接就执行了。</p>
<h1 id="57-本地存储"><a href="#57-本地存储" class="headerlink" title="57.本地存储"></a>57.本地存储</h1><pre><code>- localStorage、sessionStorage、cookie三者的区别
存储大小
    cookie数据大小不能超过4k ；
    sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大；
有效时间
    localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
    sessionStorage 数据在当前浏览器窗口关闭后自动删除；
    cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭；
数据与服务器之间的交互方式
    cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端；
    sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存；
</code></pre>
<h1 id="58-会话cookie-持久cookie"><a href="#58-会话cookie-持久cookie" class="headerlink" title="58.会话cookie 持久cookie"></a>58.会话cookie 持久cookie</h1><pre><code>- 如果 cookie 不包含到期日期，则可视为会话 cookie
    - 会话 cookie 存储在内存中，决不会写入磁盘。 当浏览器关闭时，cookie 将从此永久丢失。
- 如果 cookie 包含到期日期，则可视为持久性 cookie。
    -  在指定的到期日期，cookie 将从磁盘中删除。
</code></pre>
<h1 id="59-cookie替代"><a href="#59-cookie替代" class="headerlink" title="59.cookie替代"></a>59.cookie替代</h1><pre><code>localStorage、sessionStorage
</code></pre>
<h1 id="60-if有作用域吗"><a href="#60-if有作用域吗" class="headerlink" title="60.if有作用域吗"></a>60.if有作用域吗</h1><pre><code>只有函数有作用域，if是没有作用域的。
但是有一种情况会让if看上去有作用域，就是在if &#123;&#125;语句中，使用const、let，他们会有块级作用域。
</code></pre>
<h1 id="61-promise"><a href="#61-promise" class="headerlink" title="61.promise"></a>61.promise</h1><pre><code>- promise是解决异步的方法
    - Promise对象有两个特点：
        - 1）对象的状态不受外界的影响。
        - 2）状态一旦改变，便不会再次改变。而且它的状态改变只会由（pending-&gt;fulfilled、pending-&gt;rejected）并且这两种情况只要发生其中一个，状态便固定了。
- Promise的优点：
    - 支持链式调用（可以将异步操作以同步的方式显示出来）避免回调地狱
        - 什么是回调地狱？
            - 多个回调函数层层嵌套，外层回调函数异步返回的结果是内层回调函数执行的条件
        - 回调地狱的缺点？
            - 1、可读性、可维护性差
            - 不便于异常处理
        - 什么是回调函数？
            - 函数被当做参数被传给另外一个函数
</code></pre>
<h1 id="62-async-await"><a href="#62-async-await" class="headerlink" title="62.async&#x2F;await"></a>62.async&#x2F;await</h1><pre><code>async用来修饰function，async返回promise，await写在async里面，await后面是promise
在async函数中await的作用是把promise作为同步执行
</code></pre>
<h1 id="63-什么是闭包？"><a href="#63-什么是闭包？" class="headerlink" title="63.什么是闭包？"></a>63.什么是闭包？</h1><ol>
<li>内层函数可有访问外层函数和变量</li>
<li>内层函数对外层函数的活动变量进行访问</li>
<li>内层函数执行、创建上下文，此时就形成了闭包 &#x3D;》 闭包就是一个环境<br> 一句话概括：<br> 或者说：闭包就是可以访问其他函数内部数据的函数<br> 或者说：当一个嵌套的内部（子）函数引用了嵌套外部（父）函数的变量（函数时）内部（子）函数执行就产生了闭包<ul>
<li><p>闭包的好处：延长作用域链、缓存数据、避免全局污染<br>  闭包应用：<br>      让函数外部可以操作函数内部的数据、定义S模块<br>      具有特定功能的js文件，将所有的数据和功能都封装在一个函数内部（私有的）<br>      只向外部暴露一个包含n个方法的对象或函数<br>      模块的使用者，只需要通过没看暴露的对象调用</p>
</li>
<li><p>闭包的缺点：<br>      容易造成内存泄漏<br>      常见的js内存泄漏陷阱：闭包、遗漏的定时器、定义过多的全局变量</p>
</li>
<li><p>什么叫内存溢出：<br>      指程序申请内存时，没有足够的内存提供申请者使用，导致数据无法正常存储到内存中</p>
</li>
<li><p>什么叫内存泄漏：<br>      是指程序在申请内存后，无法释放已申请的内存空间，导致系统无法及时回收内存并且分配给其他进程使用。<br>      通常少次数的内存无法及时回收并且不会得到程序造成什么影响，但是如果在内存本身就比较少获取多次导致内存<br>      无法正常回收时，就会导致内存不够用，最终导致内存溢出。</p>
</li>
</ul>
</li>
</ol>
<h1 id="64-webpack-的-bundle，chunk，module-的意思"><a href="#64-webpack-的-bundle，chunk，module-的意思" class="headerlink" title="64.webpack 的 bundle，chunk，module 的意思"></a>64.webpack 的 bundle，chunk，module 的意思</h1><pre><code>module 是 webpack 支持解析的模块；
chunk 包含多个 module，存在于 webpack 处理过程中的阶段；
bundle 包含一个或多个 chunk，是源码经过 webpack 处理后的最终版本；
</code></pre>
<h1 id="65-webpack性能优化"><a href="#65-webpack性能优化" class="headerlink" title="65.webpack性能优化"></a>65.webpack性能优化</h1><pre><code>打包公共代码
动态导入和按需加载
删除无用的代码
长缓存优化
公共代码内联
</code></pre>
<h1 id="66-webpack-的-bundle，chunk，module-的意思"><a href="#66-webpack-的-bundle，chunk，module-的意思" class="headerlink" title="66.webpack 的 bundle，chunk，module 的意思"></a>66.webpack 的 bundle，chunk，module 的意思</h1><pre><code>module 是 webpack 支持解析的模块；
chunk 包含多个 module，存在于 webpack 处理过程中的阶段；
bundle 包含一个或多个 chunk，是源码经过 webpack 处理后的最终版本；
</code></pre>
<h1 id="67-lazyload的实现原理"><a href="#67-lazyload的实现原理" class="headerlink" title="67.lazyload的实现原理"></a>67.lazyload的实现原理</h1><p>将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求。可以指向loading的地址。<br>注：图片要指定宽高<br><img  src="default.jpg" data-
                     lazyload
                     alt="image"
                     data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"
                      
                ><br>当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。</p>
<h1 id="68-this指向"><a href="#68-this指向" class="headerlink" title="68.this指向"></a>68.this指向</h1><pre><code>- 对象中的this指向当前对象
- 默认情况下指向window
- 自执行函数中this指向window
- 计时器中this指向window
- 事件中的this指向事件源
- 箭头函数中的this指向上一层的范围
- 构造函数中的this指向构造函数实例
</code></pre>
<h1 id="69-什么是原型链？"><a href="#69-什么是原型链？" class="headerlink" title="69.什么是原型链？"></a>69.什么是原型链？</h1><pre><code>访问属性时，从对象自身沿着__proto__指向，一直到Object.prototype,形成一个链式结构(访问属性时就近原则)
</code></pre>
<h1 id="70-原型对象"><a href="#70-原型对象" class="headerlink" title="70.原型对象"></a>70.原型对象</h1><pre><code>只要声明函数，系统自动产生一个对象，就叫原型对象
存放所有实例对象需要数据共享(属性或者方法)节省了内存空间 避免了全局污染 
</code></pre>
<h1 id="71-为什么写在原型上的方法或者属性，实例对象会自动继承？"><a href="#71-为什么写在原型上的方法或者属性，实例对象会自动继承？" class="headerlink" title="71.为什么写在原型上的方法或者属性，实例对象会自动继承？"></a>71.为什么写在原型上的方法或者属性，实例对象会自动继承？</h1><pre><code>所有的对象都有一个属性__proto__
因为：原型对象的constructor和实例对象中constructor指向同一个
</code></pre>
<h1 id="72-实例是如何访问到constructor属性的"><a href="#72-实例是如何访问到constructor属性的" class="headerlink" title="72.实例是如何访问到constructor属性的"></a>72.实例是如何访问到constructor属性的</h1><pre><code>实例通过proto访问到构造函数原型，构造函数原型的constructor=构造函数
</code></pre>
<h1 id="73-原型对象-、实例对象-、-构造函数三者之间的关系"><a href="#73-原型对象-、实例对象-、-构造函数三者之间的关系" class="headerlink" title="73.原型对象 、实例对象 、 构造函数三者之间的关系"></a>73.原型对象 、实例对象 、 构造函数三者之间的关系</h1><pre><code>1、实例对象是有构造函数实例化出来的
2、构造函数中有一个prototype属性 指向的是prototy原型对象
    在原型对象上有一个constructor属性 他指向是构造器 该构造器表示的是原型所在的构造函数
3、实例对象中有一个__proto__属性，指向的是实例对象的构造函数中的prototype原型对象
</code></pre>
<h1 id="74-普通函数和构造函数有哪些区别？"><a href="#74-普通函数和构造函数有哪些区别？" class="headerlink" title="74.普通函数和构造函数有哪些区别？"></a>74.普通函数和构造函数有哪些区别？</h1><pre><code>构造函数用new fn()    普通函数fn()
this指向实例	this指向window
默认返回实例，return引用类型生效，return基本类型无效
普通函数默认返回undefined，return生效
</code></pre>
<h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><h1 id="1-ajax请求的五个步骤，"><a href="#1-ajax请求的五个步骤，" class="headerlink" title="1. ajax请求的五个步骤，"></a>1. ajax请求的五个步骤，</h1><h2 id="创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。-流程：-2-ajax同步和异步的区别-同步的请求的时候，代码好比在排队，必须是一个挨着一个的去执行，前面的没有结束，后面的代码就处于一个阻塞的状态。异步执行的时候，数据请求的同时，其他代码语句也可以同步执行，比如，在数据请求的时候，由于某些愿意，需要慢慢的返回请求结果，在这个时候带宽是很空闲的，那么，代码不会等到前面的数据完全请求返回就可以开始后面的代码运行。-3-ajax-获取数据-请求方式：-get：获取数据-post：向服务器推送数据-put：给服务器上增加资源（上传图片）-delete-删除资源-向服务器传输内容方式与get一致-head：获取服务器的响应头信息-向服务器传输内容方式与get一致-传参方式-get：直接拼接路径后面-url-name-lis-age-20-psot：传参必须要写请求头-目的：为了传递解析好的数据-设置完在传递-1-xhr-setRequestHeader-‘Content-Type’-”application-x-www-form-urlencoded”-xhr-send-“name-lis-age-20”-2-xhr-setRequestHeader-‘Content-Type’-”application-json”-xhr-send-“-name-aa-age-111-”-4-有封装过-axios-吗？怎么封装的？-axios-是一个轻量的-HTTP-客户端-基于-XMLHttpRequest-服务来执行-HTTP-请求，支持丰富的配置，支持-Promise，支持浏览器端和-Node-js-端-axios-的请求是使用-Promise-来实现-XMLHttpRequset-的，promise-本身就是一个异步的处理的方案，所以-axios-是异步的"><a href="#创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。-流程：-2-ajax同步和异步的区别-同步的请求的时候，代码好比在排队，必须是一个挨着一个的去执行，前面的没有结束，后面的代码就处于一个阻塞的状态。异步执行的时候，数据请求的同时，其他代码语句也可以同步执行，比如，在数据请求的时候，由于某些愿意，需要慢慢的返回请求结果，在这个时候带宽是很空闲的，那么，代码不会等到前面的数据完全请求返回就可以开始后面的代码运行。-3-ajax-获取数据-请求方式：-get：获取数据-post：向服务器推送数据-put：给服务器上增加资源（上传图片）-delete-删除资源-向服务器传输内容方式与get一致-head：获取服务器的响应头信息-向服务器传输内容方式与get一致-传参方式-get：直接拼接路径后面-url-name-lis-age-20-psot：传参必须要写请求头-目的：为了传递解析好的数据-设置完在传递-1-xhr-setRequestHeader-‘Content-Type’-”application-x-www-form-urlencoded”-xhr-send-“name-lis-age-20”-2-xhr-setRequestHeader-‘Content-Type’-”application-json”-xhr-send-“-name-aa-age-111-”-4-有封装过-axios-吗？怎么封装的？-axios-是一个轻量的-HTTP-客户端-基于-XMLHttpRequest-服务来执行-HTTP-请求，支持丰富的配置，支持-Promise，支持浏览器端和-Node-js-端-axios-的请求是使用-Promise-来实现-XMLHttpRequset-的，promise-本身就是一个异步的处理的方案，所以-axios-是异步的" class="headerlink" title="创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。## 流程：# 2.ajax同步和异步的区别    同步的请求的时候，代码好比在排队，必须是一个挨着一个的去执行，前面的没有结束，后面的代码就处于一个阻塞的状态。异步执行的时候，数据请求的同时，其他代码语句也可以同步执行，比如，在数据请求的时候，由于某些愿意，需要慢慢的返回请求结果，在这个时候带宽是很空闲的，那么，代码不会等到前面的数据完全请求返回就可以开始后面的代码运行。# 3.ajax 获取数据    请求方式：        get：获取数据        post：向服务器推送数据        put：给服务器上增加资源（上传图片）        delete: 删除资源,向服务器传输内容方式与get一致        head：获取服务器的响应头信息,向服务器传输内容方式与get一致    传参方式        get：直接拼接路径后面 url&#x2F;?name&#x3D;lis&amp;age&#x3D;20        psot：传参必须要写请求头  目的：为了传递解析好的数据 设置完在传递              (1) xhr.setRequestHeader(‘Content-Type’,”application&#x2F;x-www-form-urlencoded”)                  xhr.send(“name&#x3D;lis&amp;age&#x3D;20”)              (2) xhr.setRequestHeader(‘Content-Type’,”application&#x2F;json”)                  xhr.send(“{name:aa,age:111}”)# 4.有封装过 axios 吗？怎么封装的？     axios 是一个轻量的 HTTP 客户端    基于 XMLHttpRequest 服务来执行 HTTP 请求，支持丰富的配置，支持 Promise，支持浏览器端和 Node.js 端    axios 的请求是使用 Promise 来实现 XMLHttpRequset 的，promise 本身就是一个异步的处理的方案，所以 axios 是异步的"></a>创建异步对象，设置请求方式和地址，用send发送请求，监听状态变化，接收返回的数据。<br>## 流程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">创建xhr</span><br><span class="line"><span class="keyword">var</span> xhr=<span class="keyword">new</span> <span class="title class_">XMLHTTPRequest</span>()</span><br><span class="line">侦听通信状态改变的事件</span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&quot;readystatechange&quot;</span>,    readyStateChangeHandler);</span><br><span class="line"><span class="title class_">Method</span> 分为 get post put <span class="keyword">delete</span>等等</span><br><span class="line"><span class="title class_">Async</span> 异步同步</span><br><span class="line">name和password是用户名和密码</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="title class_">Method</span>,<span class="variable constant_">URL</span>,<span class="title class_">Async</span>,name,password)</span><br><span class="line">发送内容给服务器</span><br><span class="line">xhr.<span class="title function_">send</span>(内容)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readyStateChangeHandler</span>(<span class="params">e</span>)&#123;</span><br><span class="line">当状态是<span class="number">4</span>时，并且响应头成功<span class="number">200</span>时，</span><br><span class="line"><span class="keyword">if</span>(xhr.<span class="property">readyState</span>===<span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span>===<span class="number">200</span>)&#123;</span><br><span class="line">打印返回的消息</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span><br></pre></td></tr></table></figure><br># 2.ajax同步和异步的区别<br>    同步的请求的时候，代码好比在排队，必须是一个挨着一个的去执行，前面的没有结束，后面的代码就<br>处于一个阻塞的状态。<br>异步执行的时候，数据请求的同时，其他代码语句也可以同步执行，比如，在数据请求的时候，由于某<br>些愿意，需要慢慢的返回请求结果，在这个时候带宽是很空闲的，那么，代码不会等到前面的数据完全<br>请求返回就可以开始后面的代码运行。<br># 3.ajax 获取数据<br>    请求方式：<br>        get：获取数据<br>        post：向服务器推送数据<br>        put：给服务器上增加资源（上传图片）<br>        delete: 删除资源,向服务器传输内容方式与get一致<br>        head：获取服务器的响应头信息,向服务器传输内容方式与get一致<br>    传参方式<br>        get：直接拼接路径后面 url&#x2F;?name&#x3D;lis&amp;age&#x3D;20<br>        psot：传参必须要写请求头  目的：为了传递解析好的数据 设置完在传递<br>              (1) xhr.setRequestHeader(‘Content-Type’,”application&#x2F;x-www-form-urlencoded”)<br>                  xhr.send(“name&#x3D;lis&amp;age&#x3D;20”)<br>              (2) xhr.setRequestHeader(‘Content-Type’,”application&#x2F;json”)<br>                  xhr.send(“{name:aa,age:111}”)<br># 4.有封装过 axios 吗？怎么封装的？<br>     axios 是一个轻量的 HTTP 客户端<br>    基于 XMLHttpRequest 服务来执行 HTTP 请求，支持丰富的配置，支持 Promise，支持浏览器端和 Node.js 端<br>    axios 的请求是使用 Promise 来实现 XMLHttpRequset 的，promise 本身就是一个异步的处理的方案，所以 axios 是异步的</h2><pre><code>封装的同时，你需要和后端协商好一些约定，请求头，状态码，请求超时时间…
设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分
请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)
状态码: 根据接口返回的不同 status ， 来执行不同的业务，这块需要和后端约定好
请求方法：根据 get、post 等方法进行一个再次封装，使用起来更为方便
请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问
响应拦截器：这块就是根据 后端`返回来的状态码判定执行不同业务
</code></pre>
<h1 id="5-ajax状态码"><a href="#5-ajax状态码" class="headerlink" title="5.ajax状态码"></a>5.ajax状态码</h1><pre><code>0. 请求未初始化
1. 发起请求建立连接
2. 接受请求
3. 解析服务器
4. 请求成功
</code></pre>
<h1 id="6-什么是跨域？"><a href="#6-什么是跨域？" class="headerlink" title="6.什么是跨域？"></a>6.什么是跨域？</h1><pre><code>   所谓跨域 不是请求未发送 而是请求发起成功 服务器接收成功、并且服务器将数据响应给了浏览器 浏览器对数据做了拦截
</code></pre>
<p>   为什么会产生跨域？<br>       项目发布的时候不同的功能发布在不同的服务器上<br>       同源策略： 协议、域名、端口不一致就跨域</p>
<h1 id="7-如何解决跨域"><a href="#7-如何解决跨域" class="headerlink" title="7.如何解决跨域"></a>7.如何解决跨域</h1><pre><code>（1）后端设置请求头 res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)
       或者设置白名单 
           let whiteList = [&#39;http://127.0.0.1:5500&#39;]
           if(whiteList.includes(req.headers.origin))&#123;
             res.setHeader(&#39;Access-Control-Allow-Origin&#39;, req.headers.origin)
           &#125;
（2）后端用插件 
    const cors = require(&#39;cors&#39;)  app.use(cors())
（3）用json的原理
    JSONP 是一种非正式传输协议，可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，
   - 当GET请求从后台页面返回时，可以返回一段JavaScript代码，这段代码会自动执行，可以用来负责调用后台页面中的一个callback函数。然后服务端返回数据时会将这个callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。
</code></pre>
<h1 id="8-状态码"><a href="#8-状态码" class="headerlink" title="8.状态码"></a>8.状态码</h1><pre><code>        1**：请求收到，继续处理
        2**：操作成功收到，分析、接受
        3**：完成此请求必须进一步处理
        4**：请求包含一个错误语法或不能完成
        5**：服务器执行一个完全有效请求失败

        100——客户必须继续发出请求
        101——客户要求服务器根据请求转换HTTP协议版本

        200——交易成功
        201——提示知道新文件的URL
        202——接受和处理、但处理未完成
        203——返回信息不确定或不完整
        204——请求收到，但返回信息为空
        205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
        206——服务器已经完成了部分用户的GET请求


        300——请求的资源可在多处得到
        301——删除请求数据
        302——在其他地址发现了请求数据
        303——建议客户访问其他URL或访问方式
        304——客户端已经执行了GET，但文件未变化
        305——请求的资源必须从服务器指定的地址得到
        306——前一版本HTTP中使用的代码，现行版本中不再使用
        307——申明请求的资源临时性删除


        400——错误请求，如语法错误
        401——请求授权失败
        402——保留有效ChargeTo头响应
        403——请求不允许
        404——没有发现文件、查询或URl
        405——用户在Request-Line字段定义的方法不允许
        406——根据用户发送的Accept拖，请求资源不可访问
        407——类似401，用户必须首先在代理服务器上得到授权
        408——客户端没有在用户指定的饿时间内完成请求
        409——对当前资源状态，请求不能完成
        410——服务器上不再有此资源且无进一步的参考地址
        411——服务器拒绝用户定义的Content-Length属性请求
        412——一个或多个请求头字段在当前请求中错误
        413——请求的资源大于服务器允许的大小
        414——请求的资源URL长于服务器允许的长度
        415——请求资源不支持请求项目格式
        416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
        417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求

        
        500——服务器产生内部错误
        501——服务器不支持请求的函数
        502——服务器暂时不可用，有时是为了防止发生系统过载
        503——服务器过载或暂停维修
        504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
        505——服务器不支持或拒绝支请求头中指定的HTTP版本
</code></pre>

                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="article-nav">
                        
                        
                            <div class="article-next">
                                <a class="next"
                                   rel="next"
                                   href="/2023/11/01/04-%E7%AE%80%E6%98%93%E7%89%88%E5%B8%A6%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E7%99%BB%E5%BD%95%E5%92%8C%E6%B3%A8%E5%86%8C/"
                                   title="简易版带验证码的登录和注册js+jq"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">简易版带验证码的登录和注册js+jq</span>
                                        <span class="post-nav-item">Next posts</span>
                                    </span>
                                            <span class="right arrow-icon flex-center">
                                      <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2023
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Zhao zhao</a>
                
            </div>

            <div class="theme-info info-item default">
                Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            

            

            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        

        <!-- PC go comment -->
        
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
</main>



<!-- common -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local-search -->

    
<script src="/js/local-search.js"></script>



<!-- code-block -->


<!-- lazyload -->

    
<script src="/js/lazyload.js"></script>



<div class="">
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- category-page -->
    

    <!-- links-page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
